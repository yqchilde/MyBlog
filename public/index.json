[{"categories":["Golang"],"content":"Zinx是一个轻量级TCP服务框架，会跟着课程开始做一些笔记，消息封装模块是将消息细化，以达到将消息表达具体化的目的。","date":"2021-01-02","objectID":"/zinx-frame-v5/","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"消息封装脑图img \" 消息封装脑图 ","date":"2021-01-02","objectID":"/zinx-frame-v5/:0:0","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"封装消息接口 在之前我们的消息是在Request中作为data传递的，现在我们需要对消息进行细分，所以要抽象出一个消息接口 创建 ziface/imessage.go ，代码如下： // IMessage 将去请求的消息封装起来 type IMessage interface { // 获取消息数据段长度 GetDataLen() uint32 // 获取消息ID GetMsgId() uint32 // 获取消息内容 GetData() []byte // 设置消息ID SetMsgId(uint32) // 设置消息内容 SetData([]byte) // 设置消息数据段长度 SetDataLen(uint32) } ","date":"2021-01-02","objectID":"/zinx-frame-v5/:0:1","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"消息实体及初始化 这一块没有太多难度，直接贴代码了。 // Message 包含消息的属性 type Message struct { // 消息ID ID uint32 // 消息长度 DataLen uint32 // 消息内容 Data []byte } // NewMsgPackage 初始化消息包 func NewMsgPackage(id uint32, data []byte) *Message { return \u0026Message{ ID: id, DataLen: uint32(len(data)), Data: data, } } //获取消息数据段长度 func (msg *Message) GetDataLen() uint32 { return msg.DataLen } //获取消息ID func (msg *Message) GetMsgId() uint32 { return msg.ID } //获取消息内容 func (msg *Message) GetData() []byte { return msg.Data } //设置消息数据段长度 func (msg *Message) SetDataLen(len uint32) { msg.DataLen = len } //设计消息ID func (msg *Message) SetMsgId(msgId uint32) { msg.ID = msgId } //设计消息内容 func (msg *Message) SetData(data []byte) { msg.Data = data } ","date":"2021-01-02","objectID":"/zinx-frame-v5/:0:2","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"消息的封包与拆包  Zinx框架使用经典的 TLV(Type-Len-Value) 封包格式来解决TCP黏包问题。  TLV 即在head部分先存放数据长度，再存放数据ID，body部分存数据。这样在读消息时，先去head部分把数据长度读到，然后再把该数据向后偏移该数据长度就是整个数据，每个数据又用数据ID来区分。  关于TCP黏包 这里简单查了下资料，便于理解：当客户端调用两次send，服务端一次recv就全部读取出来，我们是希望怎么传就怎么读，保证数据的完整性。现象是这个样子，但是TCP本来就是基于字节流而不是消息包的协议，它自己说的清清楚楚：我会把你的数据变成字节流发到对面去，而且保证顺序不会乱，但是你要自己搞定字节流解析。所以这个问题其实就是“如何设计应用层协议的问题”。 创建 zinx/ziface/idatapack.go 文件，构造如下方法： 封包数据 拆包数据 得到头部长度 type IDataPack interface { // 头部长度 GetHeadLen() uint32 // 封包方法 Pack(msg IMessage) ([]byte, error) // 拆包方法 UnPack([]byte) (IMessage, error) } 创建 zinx/znet/datapack.go 文件，实现IDataPack中的全部方法： // DataPack 封包拆包类对象 type DataPack struct{} // NewDataPack 封包拆包实例初始化方法 func NewDataPack() *DataPack { return \u0026DataPack{} } // GetHeadLen 获取包头长度方法 func (d *DataPack) GetHeadLen() uint32 { // DataLen uint32(4) + MsgID uint32(4) return 8 } // Pack 封包方法 func (d *DataPack) Pack(msg ziface.IMessage) ([]byte, error) { dataBuff := bytes.NewBuffer([]byte{}) // 写DataLen if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetDataLen()); err != nil { return nil, err } // 写MsgID if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetMsgId()); err != nil { return nil, err } // 写Data数据 if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetData()); err != nil { return nil, err } return dataBuff.Bytes(), nil } // UnPack 拆包方法 func (d *DataPack) UnPack(binaryData []byte) (ziface.IMessage, error) { dataBuff := bytes.NewReader(binaryData) msg := new(Message) // 读DataLen if err := binary.Read(dataBuff, binary.LittleEndian, \u0026msg.DataLen); err != nil { return nil, err } // 读MsgID if err := binary.Read(dataBuff, binary.LittleEndian, \u0026msg.ID); err != nil { return nil, err } // 判断DataLen是否合法 if utils.GlobalObject.MaxPacketSize \u003e 0 \u0026\u0026 msg.DataLen \u003e utils.GlobalObject.MaxPacketSize { return nil, errors.New(\"Too large msg data received \") } return msg, nil } ","date":"2021-01-02","objectID":"/zinx-frame-v5/:0:3","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"测试封包拆包 构建单元测试 zinx/znet/datapack_test.go 文件，代码如下： func TestDataPack(t *testing.T) { // 模拟Server端 // 1. 创建 socketTCP listener, err := net.Listen(\"tcp\", \"127.0.0.1:7777\") if err != nil { t.Log(\"Server listener err: \", err) return } // 负责处理客户端业务 go func() { for { // 2. 从客户端读取数据，拆包处理 conn, err := listener.Accept() if err != nil { t.Log(\"Server accept err: \", err) } go func(conn net.Conn) { // 处理客户端的请求 dp := NewDataPack() for { // 2.1 第一次从conn读，把包的head读出来 headData := make([]byte, dp.GetHeadLen()) _, err := io.ReadFull(conn, headData) if err != nil { t.Log(\"Read head err: \", err) break } // 2.2 拆包 msgHead, err := dp.UnPack(headData) if err != nil { t.Log(\"Server unpack err: \", err) return } // 2.3 第二次从conn读，根据head中dataLen去拿data if msgHead.GetDataLen() \u003e 0 { msg := msgHead.(*Message) msg.Data = make([]byte, msg.GetDataLen()) // 偏移DataLen后拿数据 _, err := io.ReadFull(conn, msg.Data) if err != nil { t.Log(\"Server unpack data err: \", err) return } t.Logf(\"MsgID: %d, ReceiveLen: %d, data: %s\", msg.ID, msg.DataLen, string(msg.Data)) } } }(conn) } }() // 模拟Client端 conn, err := net.Dial(\"tcp\", \"127.0.0.1:7777\") if err != nil { t.Log(\"Client dial err: \", err) return } // 创建一个封包对象 dp := NewDataPack() // 模拟黏包过程，封装两个msg一同发送 msg1 := \u0026Message{ ID: 1, DataLen: 4, Data: []byte{'Z', 'i', 'n', 'x'}, } sendData1, _ := dp.Pack(msg1) msg2 := \u0026Message{ ID: 2, DataLen: 6, Data: []byte{'n', 'i', 'h', 'a', 'o', '!'}, } sendData2, _ := dp.Pack(msg2) sendData1 = append(sendData1, sendData2...) _, _ = conn.Write(sendData1) // 客户端阻塞 select {} } 测试结果如下： 测试img \" 测试 ","date":"2021-01-02","objectID":"/zinx-frame-v5/:0:4","tags":["Golang","Zinx"],"title":"Zinx学习之消息封装模块","uri":"/zinx-frame-v5/"},{"categories":["Golang"],"content":"Zinx是一个轻量级TCP服务框架，会跟着课程开始做一些笔记，全局配置模块主要是配置了服务启动和运行中的一些参数。","date":"2021-01-02","objectID":"/zinx-frame-v4/","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Golang"],"content":"全局配置脑图img \" 全局配置脑图 ","date":"2021-01-02","objectID":"/zinx-frame-v4/:0:0","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Golang"],"content":"配置文件 写一个全局配置是为了更方便的维护项目已经修改代码参数，创建 conf/zinx.json 文件，配置信息如下： { \"Name\": \"demo server\", \"Host\": \"127.0.0.1\", \"IPVersion\": \"tcp4\", \"TcpPort\": 8999, \"MaxConn\": 3 } ","date":"2021-01-02","objectID":"/zinx-frame-v4/:0:1","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Golang"],"content":"全局参数映射 创建 utils/globalobj.go 文件，代码编写如下： // GlobalObj 用来映射 zinx.json type GlobalObj struct { TcpServer ziface.IServer //全局Server对象 IPVersion string // IP版本 Host string //当前服务器主机IP TcpPort int //当前服务器主机监听端口号 Name string //当前服务器名称 Version string //当前服务版本号 MaxPacketSize uint32 //都需数据包的最大值 MaxConn int //当前服务器主机允许的最大链接个数 } // 定义一个全局的对象 var GlobalObject *GlobalObj //读取用户的配置文件 func (g *GlobalObj) Reload() { data, err := ioutil.ReadFile(\"conf/zinx.json\") if err != nil { panic(err) } err = json.Unmarshal(data, \u0026GlobalObject) if err != nil { panic(err) } } /* 提供init方法，默认加载 */ func init() { //初始化GlobalObject变量，设置一些默认值 GlobalObject = \u0026GlobalObj{ Name: \"ZinxServerApp\", Version: \"V4\", TcpPort: 8999, Host: \"0.0.0.0\", MaxConn: 1000, MaxPacketSize: 4096, } //从配置文件中加载一些用户配置的参数 GlobalObject.Reload() } ","date":"2021-01-02","objectID":"/zinx-frame-v4/:0:2","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Golang"],"content":"替换参数 server.go中NewServer替换 // NewServer 实例Server func NewServer(name string) ziface.IServer { return \u0026Server{ Name: utils.GlobalObject.Name, IPVersion: utils.GlobalObject.IPVersion, IP: utils.GlobalObject.Host, Port: utils.GlobalObject.TcpPort, Router: nil, } } 在server.go中Start()方法中开始加上日志信息： fmt.Printf(\"[START] Server name: %s,listenner at IP: %s, Port %d is starting\\n\", s.Name, s.IP, s.Port) fmt.Printf(\"[Zinx] Version: %s, MaxConn: %d, MaxPacketSize: %d\\n\", utils.GlobalObject.Version, utils.GlobalObject.MaxConn, utils.GlobalObject.MaxPacketSize) ","date":"2021-01-02","objectID":"/zinx-frame-v4/:0:3","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Golang"],"content":"测试 拷贝v3中的代码到v4，在v4目录下创建 conf/zinx.json ，将上面的zinx.json内容复制进去，分别运行server.go和client.go即可看到服务日志开始打印。 测试img \" 测试 ","date":"2021-01-02","objectID":"/zinx-frame-v4/:0:4","tags":["Golang","Zinx"],"title":"Zinx学习之全局配置模块","uri":"/zinx-frame-v4/"},{"categories":["Notes"],"content":"2020结束啦，第一次正式总结，祝大家新年快乐！","date":"2021-01-01","objectID":"/2020-harvest-summary/","tags":["mood"],"title":"2020 Harvest Summary","uri":"/2020-harvest-summary/"},{"categories":["Notes"],"content":" 转眼间就到2020的最后一天了，算了算时间，我也工作7个多月了，生活虽然很乱，但是好在没有止步不前。  第一次写年终总结，也许是一个好的开始，希望以后年年都坚持写。  2020本来打算早早返回学校，完成最后一个学期离开学校，没想到自寒假离校后，再见面即毕业。挺后悔自己没有实习经历的，真的就是浪费了很多机会一样，我是在19年10月接触Golang的，之前在学校写写PHP，写写前端，参加过比赛，也拿过奖，却一直没有很认真的对待。花费在选择上的时间大于学习这是我经常犯的一个毛病，要改，要改，要改。接触Go也是听着PHP圈里的人大多都在转，自己学着也觉得挺简单挺简洁的，反正一直在学吧，到今年4月的时候，在家待不住了，想着来找工作，以着应届生社招身份去面试真的是很难，而且我选择了Go，差点变成我后悔选择的语言，我是在济南求职，济南的Go岗位真的是稀缺，仅仅7-8家，只有两家要一年经验，其他都是3年以上经验，所以这两家我都投了，第一家面试等结果无果，第二家面试以为也要失败的时候，Boss给了我机会（Boss亲自面，也是技术出身），真的非常感谢给我提供机会。在这多半年来，真的是学到很多东西，有些东西只有自己上手才会知道哪里有坑，这些坑都是宝贵的经验。  社畜生活开始了，和大家一样，先是租房，租房一定要看好合同，一定不要着急确定是否要租，多看看再搞搞价都是可以谈下来的，在我住进来那段时间除了偶尔觉得房子太小，电费太贵外没有什么问题。问题出现在国庆前一天，由于傻X中介和房东出现矛盾，房东让我们搬出房子，没有时间缓冲，中午中介给我随便找了个房子，真的是随便找的，匆忙搬进去差点延误国庆回家的火车。到家后，越想越觉得不对，房子又小又吵，之前是800一月的，这间在贝壳看是600一月的，一模一样。当我开始微信联系傻X中介的时候，他玩消失了，最后堵在小区里找到的，随便应付几句说给我换房子，等了10来天也不管我，最后再次选择搬家，傻X中介不同于退，在同事帮助下利用法律诉讼要求协商退押金才结束这一些恶心事。  再说说电脑的折腾，在群里偶然接触到黑苹果这个东西，几经折腾给自己的笔记本换上了黑苹果系统，又加了固态硬盘，又买了2k显示器，这时候又发现MacOS对2k很不友好，默认在4K下才能自动开启HiDpi，故又咸鱼出掉2K显示器，用了20天折了点钱还是出掉了。又遇到了NUC8，决定把笔记本卖掉，因为总所周知的黑苹果笔记本的HDMI不能用（因为核显），入了NUC8之后又买了一块便携4K，又加了一根16G内存组成32G双通道，我都觉得自己真能够折腾的，所幸现在用的很舒服，作为开发主力机在使用。留念一下存在相机里的照片吧，讲真的，我的下一台笔记本一定是Mac Book Pro。 图11609432992667 \" 图1 图21609433015517 \" 图2 图3image-20210101010515366 \" 图3  最后说一下技术上，感觉自己的心太浮躁了，很多东西都是浅尝辄止，这就导致我知识体系很零散，无法贯穿起来，所以我想在新的一年里去把这些做好，等下一个年终回头看自己的Flag完成度。  在此立下2021Flag，愿不负时光。 重新过一遍计算机网络 重新过一遍系统结构 看关于Go进阶的5本书以上 把Docker知识梳理出来 学会CI/CD的某一项技术 看关于Redis的书 整理并深入学习Nats、RabbitMQ 看一点K8S相关方面的书 减肥（现在140想回到130） 照顾好小杨 ","date":"2021-01-01","objectID":"/2020-harvest-summary/:0:0","tags":["mood"],"title":"2020 Harvest Summary","uri":"/2020-harvest-summary/"},{"categories":["Golang"],"content":"Zinx是一个轻量级TCP服务框架，会跟着课程开始做一些笔记，Router模块主要封装了Request接口和Router接口，用于实现通过路由请求数据，并且通过路由调用链接功能，v3是单路由模式。","date":"2020-12-27","objectID":"/zinx-frame-v3/","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"Router模块脑图img \" Router模块脑图 现在我们需要给用户一个自定的Conn处理业务的接口，需要用户传入所需要处理的业务，而不是写死的回显方法。我们需要定义一些 interface{} 来让用户填写任意格式的连接处理业务方法。 那么，很显然func不能满足我们的需求，接下来就是定义抽象的接口类。 我们需要把客户端请求的连接信息和请求的数据，放在一个 Request 的结构体里，这样的好处是我们可以从Request里面得到全部客户端的请求信息，也为我们之后扩展框架有一定的作用，一旦客户端有额外的含义的数据信息，都可以放在这个Request中。可以理解为每次客户端的全部请求数据，Zinx都会把它们放在一个Request结构体中。 ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:0","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"创建抽象IRequest层 在 ziface 下创建 irequest.go  // IRequest 接口 // 实际上是把客户端请求的链接信息和请求的数据包装到一个request中 type IRequest interface { // 得到当前链接 GetConnection() IConnection // 得到请求的消息数据 GetData() []byte } ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:1","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"创建实体Request层 在 znet 下创建 request.go  type Request struct { // 已经和客户端建立好的链接 conn ziface.IConnection // 客户端请求的数据 data []byte } func (r *Request) GetConnection() ziface.IConnection { return r.conn } func (r *Request) GetData() []byte { return r.data } request 相关的封装好了，接下来是配置 Router 层，目的是为了在router里面携带服务要处理的业务 ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:2","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"创建抽象的IRouter层 在 ziface 下创建 irouter.go 我们知道 router 实际上的作用就是，服务端应用可以给 Zinx 框架配置当前链接的处理业务方法，之前是写死的回显方法，有了router就可以通过router携带，并且会定义三个方法，且支持方法重写。 PreHandle: 在处理conn业务之前的钩子方法Hook Handle: 在处理conn业务的主方法Hook PostHandle: 在处理conn业务之后的钩子方法Hook 每个方法的形参就是上面封装的 IRequest 对象，用来告知我们所要连的链接以及请求数据，作为我们业务方法的输入数据。 // IRouter 路由抽象接口 // 路由里的数据都是IRequest type IRouter interface { // 在处理conn业务之前的钩子方法Hook PreHandle(request IRequest) // 在处理conn业务的主方法Hook Handle(request IRequest) // 在处理conn业务之后的钩子方法Hook PostHandle(request IRequest) } ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:3","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"创建实体Router层 type BaseRouter struct{} // PreHandle 在处理conn业务之前的钩子方法Hook func (br *BaseRouter) PreHandle(request ziface.IRequest) { } // Handle 在处理conn业务的主方法Hook func (br *BaseRouter) Handle(request ziface.IRequest) { } // PostHandle 在处理conn业务之后的钩子方法Hook func (br *BaseRouter) PostHandle(request ziface.IRequest) { } 我们注意到了，在实体的Router层里我们写了空的结构体 BaseRouter ，这里讲一下目的。在实现router时，我们要基于 BaseRouter ，也就是面向对象中的继承基类，继承之后就可以对这个基类的方法进行重写。 举个例子，有的router没有前置或后置处理业务，在继承基类后，有需要写的就直接重写方法即可，不需要的直接忽略即可。 ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:4","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"IServer 添加路由添加功能 我们需要给 IServer 结构体中添加一个方法 AddRouter ，目的是让框架使用者自定义一个Router处理业务方法。 在 zinx/ziface/iserver.go 修改如下： type IServer interface { // 启动 Start() // 结束 Stop() // 运行 Serve() // 路由功能，给当前的服务注册一个路由方法 AddRouter(router IRouter) } ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:5","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"Server中添加Router成员 在 zinx/znet/server.go 修改如下： type Server struct { Name string IPVersion string IP string Port int // 给当前的Server添加一个router，Server注册的链接对应的处理业务 Router ziface.IRouter } 在初始化 NewServer() 方法中也要添加一个初始化成员 func NewServer(name string) ziface.IServer { return \u0026Server{ Name: name, IPVersion: \"tcp4\", IP: \"0.0.0.0\", Port: 8999, Router: nil, // 初始化为nil } } 还记得在之前临时在 Connection 中添加了一个 handleAPI ziface.HandleFunc ，目的是为了直接在业务处理方法，如今我们封装了Router，就是为了在Router中携带业务方法，所以可以删掉了，然后添加处理的 Router 对象，如下： // 链接模块 type Connection struct { // 当前链接的socket TCP套接字 Conn *net.TCPConn // 链接的ID ConnID uint32 // 当前的链接状态 isClosed bool // 告知当前链接已经退出/停止的 channel ExitChan chan bool // 该链接处理的方法Router Router ziface.IRouter } 然后去实现接口中的 AddRouter 方法 func (s *Server) AddRouter(r ziface.IRouter) { s.Router = r log.Println(\"Add router success!\") } 同样在初始化 NewConnection 中添加router // 初始化链接模块的方法 func NewConnection(conn *net.TCPConn, connID uint32, router ziface.IRouter) *Connection { return \u0026Connection{ Conn: conn, ConnID: connID, isClosed: false, Router: router, ExitChan: make(chan bool, 1), } } 接下来当然是去处理之前在 StartReader() 中写的调用 HandleFunc 方法 删掉： if err := c.handleAPI(c.Conn, buf, cnt); err != nil { log.Println(\"ConnID = \", c.ConnID, \"Handle is error: \", err) break } 添加： // 从路由中，找到注册绑定的Conn对应的router调用 req := Request{ conn: c, data: buf, } // 执行注册的路由方法 go func(request ziface.IRequest) { c.Router.PreHandle(request) c.Router.Handle(request) c.Router.PostHandle(request) }(\u0026req) 以上完成了Zinx的路由模块功能，接下来是测试了。 拷贝之前的 v2 测试包重命名为 v3。修改 Server.go ，我们实现一个 IRouter ，并重写里面的三个方法，如下： type PingRouter struct { znet.BaseRouter } // PreHandle 在处理conn业务之前的钩子方法Hook func (p *PingRouter) PreHandle(request ziface.IRequest) { log.Println(\"Call Router PreHandle\") _, err := request.GetConnection().GetTCPConnection().Write([]byte(\"before.ping...\\n\")) if err != nil { log.Println(\"before ping error is \", err) } } // Handle 在处理conn业务的主方法Hook func (p *PingRouter) Handle(request ziface.IRequest) { log.Println(\"Call Router Handle\") _, err := request.GetConnection().GetTCPConnection().Write([]byte(\"ping...\\n\")) if err != nil { log.Println(\"ping error is \", err) } } // PostHandle 在处理conn业务之后的钩子方法Hook func (p *PingRouter) PostHandle(request ziface.IRequest) { log.Println(\"Call Router PostHandle\") _, err := request.GetConnection().GetTCPConnection().Write([]byte(\"after.ping...\\n\")) if err != nil { log.Println(\"after ping error is \", err) } } 在 main 方法中添加 Router  func main() { server := znet.NewServer(\"Zinx v3\") // 添加自定义router server.AddRouter(\u0026PingRouter{}) server.Serve() } 测试结果如下图：（可以看出三个方法按照链式进行） 测试结果image \" 测试结果 现在Zinx框架的路由只是单路由结构，后续会增加多路由功能 ","date":"2020-12-27","objectID":"/zinx-frame-v3/:0:6","tags":["Golang","Zinx"],"title":"Zinx学习之Router模块","uri":"/zinx-frame-v3/"},{"categories":["Golang"],"content":"Zinx是一个轻量级TCP服务框架，会跟着课程开始做一些笔记，基础链接封装和业务绑定模块模块是将v1中直接在start方法中的功能抽象出一个Connection，该Connection又有业务绑定功能。","date":"2020-12-27","objectID":"/zinx-frame-v2/","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"基础链接封装和业务绑定模块脑图img \" 基础链接封装和业务绑定模块脑图 v1版本已经实现了一个基础的Server框架，现在我们需要对客户端链接和不同的客户端链接所处理的不同业务在做一层接口封装。在ziface下创建一个链接的接口文件 iconnection.go ，以及在znet目录下的实现文件 connection.go 。 ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:0","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"定义IConnection接口 // IConnection 定义链接模块的抽象层 type IConnection interface { // 启动链接 让当前的链接准备开始工作 Start() // 停止链接 结束当前链接的工作 Stop() // 获取当前链接的绑定 socket conn GetTCPConnection() *net.TCPConn // 获取当前链接模块的链接ID GetConnID() uint32 // 获取远程客户端的 TCP 状态 IP Port RemoteAddr() net.Addr // 发送数据 将数据发送给远程的客户端 Send(data []byte) error } // 定义一个处理链接业务的方法 // 传入TCP句柄，数据以及长度 type HandleFunc func(*net.TCPConn, []byte, int) error ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:1","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"定义Connection结构体 // 链接模块 type Connection struct { // 当前链接的socket TCP套接字 Conn *net.TCPConn // 链接的ID ConnID uint32 // 当前的链接状态 isClosed bool // 该链接的处理方法API handleAPI ziface.HandleFunc // 告知当前链接已经退出/停止的 channel ExitChan chan bool } // 初始化链接模块的方法 func NewConnection(conn *net.TCPConn, connID uint32, callback_api ziface.HandFunc) *Connection { return \u0026Connection{ Conn: conn, ConnID: connID, isClosed: false, handleAPI: callback_api, ExitChan: make(chan bool, 1), } } ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:2","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"实现IConnection接口所有方法 Start()方法 // Start ... func (c *Connection) Start() { log.Printf(\"Connection Start... ConnID = %d\", c.ConnID) // 启动从当前链接的读数据的业务 go c.StartReader() } // 此时单独构造了一个StartReader方法，用来处理开始读的业务 // StartReader 开始读的业务 func (c *Connection) StartReader() { log.Println(\"Reader Goroutine is running...\") // 读完业务结束 defer c.Stop() // 具体业务 for { // 读取客户端的数据到buf中，最大512字节 buf := make([]byte, 512) cnt, err := c.Conn.Read(buf) if err != nil { log.Println(\"read buf error \", err) continue } // 调用当前链接绑定HandleFunc if err := c.handleAPI(c.Conn, buf, cnt); err != nil { log.Println(\"ConnID = \", c.ConnID, \"Handle is error: \", err) break } } } Stop()方法 // Stop 停止链接 结束当前链接的工作 func (c *Connection) Stop() { log.Printf(\"Connection Stop... ConnID = %d\", c.ConnID) // 如果已经关闭 if c.isClosed { return } // 关闭链接 c.isClosed = true _ = c.Conn.Close() // 回收资源 close(c.ExitChan) } GetTCPConnection()方法 // GetTCPConnection 获取当前链接的绑定 socket conn func (c *Connection) GetTCPConnection() *net.TCPConn { return c.Conn } GetConnID()方法 // GetConnID 获取当前链接模块的链接ID func (c *Connection) GetConnID() uint32 { return c.ConnID } RemoteAddr()方法 // RemoteAddr 获取远程客户端的 TCP 状态 IP Port func (c *Connection) RemoteAddr() net.Addr { return c.Conn.RemoteAddr() } Send()方法 // Send 发送数据 将数据发送给远程的客户端 func (c *Connection) Send(data []byte) error { // todo return nil } ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:3","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"链接绑定方法处理 在v1中回显功能直接写在Start方法中，但是在v2中我们在Connection结构体中定义了该链接的处理方法API： handleFunc ，所以我们去 server.go 外部实现一个回显功能的方法，如下： // CallBackToClient 定义当前客户端链接所绑定的handle api func CallBackToClient(conn *net.TCPConn, data []byte, cnt int) error { // 回显的业务 if _, err := conn.Write(data[:cnt]); err != nil { log.Println(\"write back buf err is \", err) return errors.New(\"CallBackToClient error\") } return nil } 在 Start() 方法中将原本的回显功能删掉，使用 NewConnection 去直接绑定一个链接和该链接绑定的业务方法。 func (s *Server) Start() { fmt.Printf(\"[Start] Server Listener at IP: %s, Port: %d, is starting\\n\", s.IP, s.Port) go func() { // 1. 获取一个TCP的Addr addr, err := net.ResolveTCPAddr(s.IPVersion, fmt.Sprintf(\"%s:%d\", s.IP, s.Port)) if err != nil { log.Println(\"resolve tcp addr error: \", err) return } // 2. 监听服务器的地址 listener, err := net.ListenTCP(s.IPVersion, addr) if err != nil { log.Println(\"listen \", s.IPVersion, \"error \", err) return } log.Println(\"Start Zinx server success, \", s.Name, \"Listening...\") var cid uint32 = 0 // 3. 阻塞等待服务器链接，处理客户端链接业务（读写） for { // 如果有客户端连接，阻塞会返回 conn, err := listener.AcceptTCP() if err != nil { log.Println(\"Accept error \", err) continue } // 将处理新链接的业务方法和conn进行绑定，得到链接模块 dealConn := NewConnection(conn, cid, CallBackToClient) cid++ // 启动业务模块 go dealConn.Start() } }() } ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:4","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"测试 将v1的测试复制一份到v2里面，将其中的log信息修改为v2的数据，在两个控制台分别运行server.go和client.go 可以看到客户端一直发送数据，服务端也可以一直接收到。 ","date":"2020-12-27","objectID":"/zinx-frame-v2/:0:5","tags":["Golang","Zinx"],"title":"Zinx学习之基础链接封装和业务绑定模块","uri":"/zinx-frame-v2/"},{"categories":["Golang"],"content":"Zinx是一个轻量级TCP服务框架，会跟着课程开始做一些笔记，Server模块是快速实现Zinx最小版本的一个基础模块。","date":"2020-12-27","objectID":"/zinx-frame-v1/","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"第一章 基础Server Server脑图img \" Server脑图 ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:0","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"创建抽象与实体模块 首先创建两个模块使用，一个是 ziface ，一个是 znet ，分别创建 ziface/iserver.go 和 znet/server.go 作为接口，我们对外只提供方法，故抽象出三个方法，分别是： 启动服务器方法 停止服务器方法 开启业务服务方法 iserver.go : // IServer 定义Server抽象层 type IServer interface { // 启动 Start() // 结束 Stop() // 运行 Serve() } 在server.go中定义Server结构体实现三个属性 服务器名 服务器IP 服务器监听端口 IP版本（IPv4、IPv6） // Server 包含一个服务必要的属性 type Server struct { Name string IPVersion string IP string Port int } // NewServer 实例Server func NewServer(name string) ziface.IServer { return \u0026Server{ Name: name, IPVersion: \"tcp4\", IP: \"0.0.0.0\", Port: 8999, } } 接下来去实现IServer中所有方法 启动一个服务器需要分为三步： 获取TCP的地址 监听服务器地址 启动Server网络连接业务 ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:1","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"实现Start() 方法 // Start ... func (s *Server) Start() { fmt.Printf(\"[Start] Server Listener at IP: %s, Port: %d, is starting\\n\", s.IP, s.Port) go func() { // 1. 获取一个TCP的Addr addr, err := net.ResolveTCPAddr(s.IPVersion, fmt.Sprintf(\"%s:%d\", s.IP, s.Port)) if err != nil { log.Println(\"resolve tcp addr error: \", err) return } // 2. 监听服务器的地址 listener, err := net.ListenTCP(s.IPVersion, addr) if err != nil { log.Println(\"listen \", s.IPVersion, \"error \", err) return } log.Println(\"Start Zinx server success, \", s.Name, \"Listening...\") // 3. 阻塞等待服务器链接，处理客户端链接业务（读写） for { // 如果有客户端连接，阻塞会返回 conn, err := listener.AcceptTCP() if err != nil { log.Println(\"Accept error \", err) continue } // 暂时做一个最大512字节的回显功能 go func () { //不断的循环从客户端获取数据 for { buf := make([]byte, 512) cnt, err := conn.Read(buf) if err != nil { fmt.Println(\"recv buf err \", err) continue } //回显 if _, err := conn.Write(buf[:cnt]); err !=nil { fmt.Println(\"write back buf err \", err) continue } } }() } }() } ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:2","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"实现Stop() 方法 // Stop ... func (s *Server) Stop() { log.Println(\"[STOP] Zinx server , name \", s.Name) } ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:3","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"实现Serve() 方法 // Serve ... func (s *Server) Serve() { // 启动服务 s.Start() // todo 用来再此处处理其他业务 // 阻塞在此，防止主协程结束 select {} } ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:4","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"测试 在项目中创建 v1/client.go 和 v1/server.go 代码分别如下： // client.go package main import ( \"log\" \"net\" \"time\" ) func main() { log.Println(\"client start...\") time.Sleep(1 * time.Second) // 1. 直接链接远程服务器，得到一个conn链接 conn, err := net.Dial(\"tcp\", \"127.0.0.1:8999\") if err != nil { log.Println(\"client start error \", err) return } // 2. 链接调用write写数据 for { _, err := conn.Write([]byte(\"Hello Zinx v1\")) if err != nil { log.Println(\"write buf error \", err) return } buf := make([]byte, 512) cnt, err := conn.Read(buf) if err != nil { log.Println(\"read buf error \", err) return } log.Printf(\"Server call back %s, cnt = %d\\n\", buf, cnt) // CPU阻塞 time.Sleep(1 * time.Second) } } // server.go package main import \"Zinx/znet\" func main() { server := znet.NewServer(\"Zinx v1\") server.Serve() } 在控制台分别运行server.go 和 client.go 可以看到client一直在发送，server也可以接收。 ","date":"2020-12-27","objectID":"/zinx-frame-v1/:1:5","tags":["Golang","Zinx"],"title":"Zinx学习之基础Server模块","uri":"/zinx-frame-v1/"},{"categories":["Golang"],"content":"在写路由中间件时有一个需求，去获取Request携带的参数然后去拦截是否合法，这时候在下游的Controller层再次去获取body竟然发现结果为空，特此记录原因和解决方案","date":"2020-12-19","objectID":"/golang-request-body-reuse/","tags":["Golang"],"title":"Golang之Request.Body复用","uri":"/golang-request-body-reuse/"},{"categories":["Golang"],"content":" 在写路由中间件时有一个需求，去获取Request携带的参数然后去拦截是否合法，这时候在下游的Controller层再次去获取body竟然发现结果为空，特此记录原因和解决方案 由于http.Request.Body是io.ReadCloser类型，所以需要带有无操作close方法的ReadCloser去复制 ","date":"2020-12-19","objectID":"/golang-request-body-reuse/:0:0","tags":["Golang"],"title":"Golang之Request.Body复用","uri":"/golang-request-body-reuse/"},{"categories":["Golang"],"content":"解决方案 // 假设r是http.Request类型 // 我们拿到body字节流数据 b, _ := ioutil.ReadAll(r.Body) // 用该方法继续将数据写入Body用于传递 r.Body = ioutil.NopCloser(bytes.NewBuffer(b)) ","date":"2020-12-19","objectID":"/golang-request-body-reuse/:1:0","tags":["Golang"],"title":"Golang之Request.Body复用","uri":"/golang-request-body-reuse/"},{"categories":["Golang"],"content":"分析原因 大多数Http框架都是这样实现的，只读一次，是因为持有的缓冲区的指针都是往前读的，如果一直持有缓冲区而不释放会出问题，可以想象一下，假如可以多次重复读，那么用户连接所产生的的内存占用的缓冲区有多大呢？什么时候释放呢？ 在实际开发中，响应主体持有的资源可能会很大，所以并不会将其直接保存在内存中，只是持有数据流连接。当我们需要时，才会从服务器获取数据并返回。同时，考虑到应用重复读取数据的可能性很小，所以将其设计为一次性流（one-shot）,即“读取后立即关闭并释放资源”。 ","date":"2020-12-19","objectID":"/golang-request-body-reuse/:2:0","tags":["Golang"],"title":"Golang之Request.Body复用","uri":"/golang-request-body-reuse/"},{"categories":["Golang"],"content":"源码分析 待更新… ","date":"2020-12-19","objectID":"/golang-request-body-reuse/:3:0","tags":["Golang"],"title":"Golang之Request.Body复用","uri":"/golang-request-body-reuse/"},{"categories":["Docker"],"content":"解决Ubuntu启动Docker 'Got permission denied while trying to connect to the Docker daemon socket' 问题。","date":"2020-11-11","objectID":"/ubuntu-docker-permission-denied/","tags":["Docker"],"title":"Ubuntu启动Docker报没有权限","uri":"/ubuntu-docker-permission-denied/"},{"categories":["Docker"],"content":"问题描述 ​ 解决Ubuntu启动Docker “Got permission denied while trying to connect to the Docker daemon socket” 问题。在终端执行 docker version 命令，出现以下错误 docker versionimage-20201111081455844 \" docker version ","date":"2020-11-11","objectID":"/ubuntu-docker-permission-denied/:1:0","tags":["Docker"],"title":"Ubuntu启动Docker报没有权限","uri":"/ubuntu-docker-permission-denied/"},{"categories":["Docker"],"content":"原因分析 ​ docker进程使用 Unix Socket 而不是 TCP 端口。而默认情况下，Unix socket 属于 root 用户，因此需要 root权限 才能访问。 ","date":"2020-11-11","objectID":"/ubuntu-docker-permission-denied/:2:0","tags":["Docker"],"title":"Ubuntu启动Docker报没有权限","uri":"/ubuntu-docker-permission-denied/"},{"categories":["Docker"],"content":"解决方案 ​ 将 docker 添加进用户组，代码如下，依次执行： 1. 添加docker用户组 sudo groupadd docker 2. 检测当前用户是否已经在docker用户组中，其中XXX为系统用户名 sudo gpasswd -a $XXX docker 3. 将当前用户添加至docker用户组 sudo gpasswd -a $USER docker 4. 更新docker用户组 newgrp docker 解决方案image-20201111081917641 \" 解决方案 ","date":"2020-11-11","objectID":"/ubuntu-docker-permission-denied/:3:0","tags":["Docker"],"title":"Ubuntu启动Docker报没有权限","uri":"/ubuntu-docker-permission-denied/"},{"categories":["Docker"],"content":"检查结果 再次执行 docker version 命令，发现不再出现缺失权限的问题 本文参考文章： CSDN ","date":"2020-11-11","objectID":"/ubuntu-docker-permission-denied/:4:0","tags":["Docker"],"title":"Ubuntu启动Docker报没有权限","uri":"/ubuntu-docker-permission-denied/"},{"categories":["MySQL"],"content":"在Ubuntu系统中安装了MySQL之后,不知道密码是什么无法登录，本文记录解决方案。","date":"2020-11-10","objectID":"/ubuntu-mysql-lost-passowrd/","tags":["MySQL"],"title":"Ubuntu安装MySQL后没有初始密码之解决方案","uri":"/ubuntu-mysql-lost-passowrd/"},{"categories":["MySQL"],"content":"​ ​ 在Ubuntu系统中安装了MySQL之后，根据操作看是有一个交互需要设置密码的，但是并没有出现设置密码的环节，压根登录不了，尝试查看过 var/log/mysql/error.log，看到的内容显示密码为空，还是没有用。 ​ 解决方案如下： 在终端输入 sudo cat/etc/mysql/debian.cnf，如下图 debian.cnfimage-20201110235553156 \" debian.cnf 用上面的user 和 password 登录mysql，如图 登录成功image-20201110235713406 \" 登录成功 登录进来之后，就可以修改mysql的密码了，使用到的命令如下，也可以参考之前的 MySQL5.7修改root密码 1. 选择mysql库 use mysql 2. 更新密码 update mysql.user set authentication_string=password('这里设置新密码') where user='root' and Host ='localhost'; 3. 更新plugin update user set plugin=\"mysql_native_password\"; 4. 刷新 flush privileges; 5. 退出 quit; ​ 操作如图所示： 修改密码image-20201111080453889 \" 修改密码 重启MySQL服务 sudo service mysql restart 以上就是全部，再次登录使用root和设置的密码就可以登录 本文参考文章CNBLOGS ","date":"2020-11-10","objectID":"/ubuntu-mysql-lost-passowrd/:0:0","tags":["MySQL"],"title":"Ubuntu安装MySQL后没有初始密码之解决方案","uri":"/ubuntu-mysql-lost-passowrd/"},{"categories":["Notes"],"content":"折腾来折腾去又回到了windows，因为一块2k屏抛弃了体验良好的黑苹果，由于装了企业版，发现企业版不会带Microsoft Store，故查资料发现了解决方法，此文插眼记录。","date":"2020-11-08","objectID":"/win10-missing-microsoftstore/","tags":["mood"],"title":"win10企业版缺失Microsoft Store及一键切换版本","uri":"/win10-missing-microsoftstore/"},{"categories":["Notes"],"content":" 折腾来折腾去又回到了windows，因为一块2k屏抛弃了体验良好的黑苹果，由于装了企业版，发现企业版不会带Microsoft Store，故查资料发现了解决方法，此文插眼记录。 ","date":"2020-11-08","objectID":"/win10-missing-microsoftstore/:0:0","tags":["mood"],"title":"win10企业版缺失Microsoft Store及一键切换版本","uri":"/win10-missing-microsoftstore/"},{"categories":["Notes"],"content":"下载包 打开网址 Microsoft Store - Generation Projec 以 PackageFamilyName 方式搜索 Microsoft.WindowsStore_8wekyb3d8bbwe 根据系统选择对应的包，一共需要下载4个安装包（每类种选择一个）都要下载(64位可以下载32的，32只下载32的就可) 选择版本image-20201108190353787 \" 选择版本 ","date":"2020-11-08","objectID":"/win10-missing-microsoftstore/:1:0","tags":["mood"],"title":"win10企业版缺失Microsoft Store及一键切换版本","uri":"/win10-missing-microsoftstore/"},{"categories":["Notes"],"content":"安装包 以上下载的文件放在同一个文件夹中，然后在当前目录打开Powershell，执行如下命令进行安装 Add-AppxPackage * 随后看到进度条下载中就说明ok，然后就可以搜到Store应用了 本文参考自：CSDN ","date":"2020-11-08","objectID":"/win10-missing-microsoftstore/:2:0","tags":["mood"],"title":"win10企业版缺失Microsoft Store及一键切换版本","uri":"/win10-missing-microsoftstore/"},{"categories":["Notes"],"content":"win一键切换版本 企业版太不适合开发党了，想下载个新版 Terminal版本都不够，只能切换到专业版了 一键切换软件image-20201108191221252 \" 一键切换软件 下载地址：https://wwa.lanzous.com/ihWfli71vzc 密码:2vgu ","date":"2020-11-08","objectID":"/win10-missing-microsoftstore/:3:0","tags":["mood"],"title":"win10企业版缺失Microsoft Store及一键切换版本","uri":"/win10-missing-microsoftstore/"},{"categories":["Golang"],"content":"了解正则表达式环视的使用方法，知道Golang为什么不支持该功能，实现一个简单的密码强度验证。","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":" 最近写了一个正则来表达遇到了一个问题，特此记录 ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:0:0","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"了解规则 密码强度规则 必须有大写字母 必须有小写字母 必须有一个数字或者标点符号 密码长度为6到14位 首先看一下正则表达式 ^((?=.*\\d)|(?=.*[\\\\\\^\\$\\.\\*\\+\\?\\{\\}\\(\\)\\[\\]\\|]+))(?=.*[a-z])(?=.*[A-Z]).{6, 14}$ 匹配结果image-20200915220733612 \" 匹配结果 可以看到图片，该正则是可以正确判断的 那么我们把该正则用Go写一下，如下 func main() { reg := `^((?=.*\\d)|(?=.*[\\\\\\^\\$\\.\\*\\+\\?\\{\\}\\(\\)\\[\\]\\|]+))(?=.*[a-z])(?=.*[A-Z]).{6, 14}$` matchString, err := regexp.MatchString(reg, \"123456\") if err != nil { log.Println(\"err is \", err) } log.Println(\"Res is \", matchString) } 报错如下 2020/09/15 21:51:46 err is error parsing regexp: invalid or unsupported Perl syntax: `(?=` 拿着该问题去google一下，发现官方并不支持正则中的 环视（lookaround），说是不符合Go的风格，因为它的复杂度相对比较高，毕竟是要全局去搜一下的 The go regexp package uses RE2 syntax, not PCRE github.com/google/re2/wiki/Syntax ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:1:0","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"代替方法 那既然正则不支持了，就只能通过写个方法代替了，不过也比较简单，如下 func VerifyPasswordRule(str string, minLen, maxLen int) error { var ( isUpper = false isLower = false isNumber = false isSpecial = false ) if len(str) \u003c minLen || len(str) \u003e maxLen { return errors.New(\"The password must contain uppercase and lowercase letters, numbers or punctuation, and must be 6-14 digits long. \") } for _, s := range str { switch { case unicode.IsUpper(s): isUpper = true case unicode.IsLower(s): isLower = true case unicode.IsNumber(s): isNumber = true case unicode.IsPunct(s) || unicode.IsSymbol(s): isSpecial = true default: } } if (isUpper \u0026\u0026 isLower) \u0026\u0026 (isNumber || isSpecial) { return nil } return errors.New(\"The password must contain uppercase and lowercase letters, numbers or punctuation, and must be 6-14 digits long. \") } ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:2:0","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"了解环视 环视是什么，环视是正则中的一个难点，但是在实际应用起来真的很方面，比如去寻找一个串中是否出现过的这种情况就十分方便，但是由于全局去遍历也就导致了他的复杂度上来。环视不匹配文本中的任何字符，只匹配文本中的特定位置。环视类似于定位符 ^, $, \\b，不会占用字符 环视分为 顺序环视、 逆序环视两种 ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:3:0","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"顺序环视 类型 正则表达式 匹配成功的条件 肯定顺序环视 (?=exp) 子表达式 能够 匹配 右侧 文本 否定顺序环视 (?!exp) 子表达式 不能 匹配 右侧 文本 顺序环视会检查子表达式 exp 能否匹配成功，且只寻找子表达式匹配成功时左侧位置，即子表达式能够匹配右侧文本 顺序环视image-20200915225541491 \" 顺序环视 ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:3:1","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"逆序环视 类型 正则表达式 匹配成功的条件 肯定逆序环视 (?\u003c=exp) 子表达式 能够 匹配 左侧 文本 否定逆序环视 (?\u003c!exp) 子表达式 不能 匹配 左侧 文本 逆序环视同样会检查字表达式子 exp的匹配，这次匹配的是左侧文本 逆序环视image-20200915225506021 \" 逆序环视 ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:3:2","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Golang"],"content":"例子 比较经典的有数字显示问题，比如我们常见到的 12345 要显示成 12,345，就是从右往左每隔三个位置加一个逗号 // 正序环视 (?\u003c=\\d)(?=(\\d{3})+$) // 逆序环视 (?=(\\d{3})+$)(?\u003c=\\d) 用以上的表达式匹配位置替换为逗号即可 ","date":"2020-09-15","objectID":"/regex-lookground-verify-passowrd/:3:3","tags":["Golang"],"title":"Golang一个简单的密码强度验证","uri":"/regex-lookground-verify-passowrd/"},{"categories":["Docker"],"content":"Docker无疑是云原生时代不可缺少的知识技能，我将一点一点学Docker，循序渐进，本文作为自己学习Docker的笔记","date":"2020-09-05","objectID":"/docker-study-notes/","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"安装 首先在安装Docker之前，需要添加Docker安装源 $ sudo yum-config-manager\\ -add-repo\\ https://download.docker.com/linux/centos/docker-ce-repo 安装最新版本docker $ sudo yum install docker-ce docker-ce-cli containerd.io ","date":"2020-09-05","objectID":"/docker-study-notes/:1:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"启动 $ sudo systemctl start docker ","date":"2020-09-05","objectID":"/docker-study-notes/:2:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"容器原理技术 ","date":"2020-09-05","objectID":"/docker-study-notes/:3:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Chroot chroot 是在Unix和Linux系统的一个操作，针对正在运行的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由chroot 设置根目录的程序，他不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。 ","date":"2020-09-05","objectID":"/docker-study-notes/:3:1","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Namespace Namespace对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行并且只可以访问当前容器命名空间的资源。 Namesapce可以隔离进程ID、主机名、用户ID、文件名、网络访问和进程间通信等相关资源。 Docker用到以下五种命名空间 Pid Namespace 用于隔离进程ID Net Namespace 用于隔离网络接口，使用户拥有独立的IP、路由、端口等 Mnt Namespace 用于文件系统挂载点隔离 Ipc Namespace 用于信号量、消息队列和共享内存的隔离 Uts Namespace 用于主机名和域名的隔离 ","date":"2020-09-05","objectID":"/docker-study-notes/:3:2","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Cgroup Cgroup 是一种Linux内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘I/O、网络等） ","date":"2020-09-05","objectID":"/docker-study-notes/:3:3","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"联合文件系统 联合文件系统 又叫 UnionFS ，是一种通过创建文件层进程操作的文件系统，常用的联合文件系统有AUFS、Overlay和Devicemapper等 ","date":"2020-09-05","objectID":"/docker-study-notes/:3:4","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"镜像 镜像是容器不可或缺的使用条件，是以只读的文件和文件夹组合，是Docker 容器启动的先决条件 ","date":"2020-09-05","objectID":"/docker-study-notes/:4:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"容器 容器是镜像的运行实体，容器运行着真正的应用进程，容器有初建、运行、停止、暂停和删除五种状态。 在容器内部，无法看到主机上的进程、环境变量、网络等信息 ","date":"2020-09-05","objectID":"/docker-study-notes/:5:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Docker 重要组件 ","date":"2020-09-05","objectID":"/docker-study-notes/:6:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"RunC runC 是用来运行容器的轻量级工具，是真正用来运行容器的 ","date":"2020-09-05","objectID":"/docker-study-notes/:6:1","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Containerd containerd 是通过 containerd-shim 启动并管理 runC，是从Docker中剥离出来的，是真正管理了Docker生命周期的重要组件 ","date":"2020-09-05","objectID":"/docker-study-notes/:6:2","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"常用命令 // 拉取镜像 docker pull // 重命名镜像 docker tag // 查看镜像 docker image ls 或 docker images // 删除镜像 docker rmi // 构建镜像 1. docker build 基于Dockerfile构建镜像 2. docker commit 基于已经运行的容器提交为镜像 ","date":"2020-09-05","objectID":"/docker-study-notes/:7:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"拉取镜像 Docker镜像的拉取使用 docker pull 命令，命令格式一般为 $ docker pull [Registry]/[Repository]/[Image]:[Tag] Registry 为注册服务器，Docker默认会从docker.io拉取镜像，如果你有自己的镜像仓库，可以把Registry替换为自己的注册服务器 Repository 为镜像仓库，通常把一组相关联的镜像归为一个镜像仓库，library 为Docker默认的镜像仓库 Image 为镜像名称 Tag 为镜像的标签，如果不指定拉取镜像的标签，默认为 latest ","date":"2020-09-05","objectID":"/docker-study-notes/:8:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"过滤镜像 过滤镜像image-20200909204607924 \" 过滤镜像 ","date":"2020-09-05","objectID":"/docker-study-notes/:9:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"重命名镜像 如果想自定义镜像名称或者推送镜像到其他镜像仓库，你可以使用 docker tag 命令将镜像重命名。docker tag 的命令格式为 $ docker tag [SOURCE_IMAGE][:TAG] [TARGET_IMAGE][:TAG] Ps. $ docker tag telemed:latest newtelemed:telemed 在执行完如上命令后，再次查看镜像就会发现多了一个仓库名为 newtelemed 的镜像，但是它和 telemed 的 IMAGE ID 是完全一样的，实际上它们指向了同一个镜像文件，只是别名不一样而已 ","date":"2020-09-05","objectID":"/docker-study-notes/:10:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"构建镜像 构建镜像主要有两种方式： 使用 docker commit 命令从运行中的容器提交为镜像 使用 docker build 命令从 Dockerfile 构建镜像 ","date":"2020-09-05","objectID":"/docker-study-notes/:11:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"docker commit 先进入镜像中 // 没有 `[]` $ docker run -rm --name=[容器名] -it [容器名] sh / # 执行完上面的命令后，当前窗口会进入指定容器名的容器中，在容器中，执行以下命令创建一个文件并写入内容 / # touch hello.txt \u0026\u0026 echo \"I Love Docker.\" \u003e hello.txt / # 此时在容器的根目录下，已经创建了一个hello.txt文件，并写入了\"I Love Docker.\"。下面，重新打开一个命令行窗口，运行以下命令提交镜像 $ docker commit [TARGET_IMAGE] [TARGET_IMAGE][:TAG] 再次使用 docker images 就可以看到生成了 [TARGET_IMAGE][:TAG]这个镜像 ","date":"2020-09-05","objectID":"/docker-study-notes/:11:1","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"docker build 这种方式是最重要的也是最常用的镜像构建方式：Dockerfile。Dockerfile是一个包含了用户所有构建命令的文本。通过 docker build 命令可以从Dockerfile生成镜像 使用Dockerfile构建镜像具有以下特性： Dockerfile的每一行命令都会生成一个独立的镜像层，并且拥有唯一的ID Dockerfile的命令是完全透明的，通过查看Dockerfile的内容，就可以知道镜像是如何一步步构建的 Dockerfile是纯文本的，方便跟随代码一起存放在代码仓库并做版本管理 ","date":"2020-09-05","objectID":"/docker-study-notes/:11:2","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"Dockerfile常用指令 指令 简介 FROM Dockerfile除了注释第一行必须是 FROM ，FROM 后面跟镜像名称，代表我们要基于哪个基础镜像构建我们的容器 RUN RUN 后面跟一个具体的命令，类似于 Linux 命令行执行命令。 ADD 拷贝本机文件或者远程文件到镜像内 COPY 拷贝本机文件到镜像内 USER 指定容器启动的用户 ENTRYPOINT 容器的启动命令 CMD CMD 为 ENTRYPOINT 指令提供默认参数，也可以单独使用 CMD 指定容器启动参数 ENV 指定容器运行时的环境变量，格式为 key=value ARG 定义外部变量，构建镜像时可以使用 build-arg = 的格式传递参数用于构建 EXPOSE 指定容器监听的端口，格式为 [port]/tcp 或者 [port]/udp WORKDIR 为 Dockerfile 中跟在其后的所有 RUN、CMD、ENTRYPOINT、COPY 和 ADD 命令设置工作目录。 通过如下实例来熟悉一下Dockerfile FROMcentos:7COPY nginx.repo /etc/yum.repos.d/nginx.repoRUN yum install -y nginxEXPOSE80ENV HOST=mynginx CMD [\"nginx\", \"-g\", \"daemon off;\"] 分析一下上面的Dockerfile 第一行表示基于 centos:7 这个镜像来构建自定义镜像。这里需要注意，每个Dockerfile的第一行除了注释都必须以FROM开头 第二行表示拷贝本地文件 nginx.repo 文件到容器内的 /etc/yum.repos.d 目录下。这里拷贝 nginx.repo 文件是为了添加nginx的安装源 第三行表示在容器内运行 yum install -y nginx 命令，安装nginx服务到容器内，执行完第三行命令，容器内的nginx已经安装完成 第四行声明容器内业务（nginx）使用80端口对外提供服务 第五行定义容器启动时的环境变量 HOST=mynginx，容器启动后可以获取到环境变量HOST的值为mynginx 第六行定义容器的启动命令，命令格式为json数组。这里设置了容器的启动命令为nginx，并且添加了nginx的启动参数 -g 'daemon 0ff;'，使nginx以前台的方式启动。 ","date":"2020-09-05","objectID":"/docker-study-notes/:12:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Docker"],"content":"镜像的实现原理 其实Docker镜像是由一系列镜像层（layer）组成的，每一层代表了镜像构建过程中的一次提交。下面以一个镜像构建的Dockerfile来说明镜像是如何分层的。 FROMbusybosCOPY test /tmp/testRUN mkdir /tmp/testdir 上面的Dockerfile由三部组成 第一行基于 busybox 创建一个镜像层 第二行拷贝本地 test 文件到镜像内 第三行在 /test 文件夹下创建一个目录 testdir 为了验证镜像的存储结构，我们使用 docker build 命令在上面Dockerfile所在目录构建一个镜像： $ docker build -t mybusybox . 这里的Docker使用的是overlay2文件驱动，进入到 /var/lib/docker/overlay2 目录下使用 tree . 命令查看产生的镜像文件 // todo 分层的结构使得Docker镜像非常轻量，每一层根据镜像的内容都有一个唯一的ID值，当不同的镜像之间有相同的镜像层时，便可以实现不同的镜像之间共享镜像层的效果 总结一下，Docker镜像是静态的分层管理的文件组合，镜像底层的实现依赖于联合文件系统（UnionFS）。每一层代表了镜像构建过程中的一次提交，当我们需要修改镜像内的某个文件时，只需要在当前镜像层的基础上新建一个镜像层，并且只存放修改过的文件内容。 ","date":"2020-09-05","objectID":"/docker-study-notes/:13:0","tags":["Docker"],"title":"Docker学习笔记","uri":"/docker-study-notes/"},{"categories":["Tips"],"content":"博客更换到了静态Hugo生成的网页，为了部署方便，所以使用GitHub Actions来自动化部署","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"了解 在使用 GitHub Actions 前先要了解什么是GitHub Actions 推荐看阮一峰老师的文章：GitHub Actions入门教程 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:1:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"熟悉流程 首先我们在github创建自己的私有仓库，用来推Hugo生成的 public 文件夹 利用 GitHub Actions 远程连接 SSH,执行删除服务器的绑定的web目录（即运行目录） 利用 GitHub Actions SCP服务推送Github仓库下的 public 到远端服务器的web目录 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:2:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"创建Actions 前面我们已经提到先将Hugo生成的public文件夹整体推到了Github，接下来就是创建 GitHub Actions 创建Actionsimg \" 创建Actions ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:3:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"配置文件 连接SSH的选择一个Star比较多的，如下图 选择市场插件img \" 选择市场插件 这边我贴一下我配置好的 # This is a basic workflow to help you get started with Actionsname:CIon:push:branches:[master]jobs:build:runs-on:ubuntu-lateststeps:- name:CheckOutuses:actions/checkout@v2# 使用SSH远程连接- name:SSHRemoteCommandsuses:appleboy/ssh-action@masterwith:host:${{secrets.ALIYUN_HOST}}username:${{secrets.ALIYUN_USER}}password:${{secrets.ALIYUN_PASSWORD}}script:bash/root/blog_del.sh# 用SCP将文件传到远端服务器- name:SCPFilestoaliyunuses:appleboy/scp-action@masterwith:host:${{secrets.ALIYUN_HOST}}username:${{secrets.ALIYUN_USER}}password:${{secrets.ALIYUN_PASSWORD}}source:\"./public\"target:${{secrets.ALIYUN_PATH}} 注意 ${{ secrets.xxx }} 是官方设置秘钥的方法 ${{ secrets.ALIYUN_HOST }} 服务器地址 ${{ secrets.ALIYUN_USER }} 服务器用户名 ${{ secrets.ALIYUN_PASSWORD }} 服务器密码 ${{ secrets.ALIYUN_PATH }} 博客运行目录 第24行的运行脚本是指在连接到远端服务器时，先去删除服务器上原本的文件 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:4:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"删除远端目录 删除远端目录img \" 删除远端目录 if [ ! -d \"远端目录\" ];then echo \"文件夹不存在\" else rm -rf 远端目录 fi ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:4:1","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"secrets添加 secrets添加位置img \" secrets添加位置 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:4:2","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"推送 点击右上角保存即可，这样每次只需要在本地将文章推到GitHub就可以自动部署到服务器了。 运行日志img \" 运行日志 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:5:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"补充 2020/09/01 补充 Algolia搜索的自动同步 本站搜索用的是Algolia搜索，由于每次需要手动将Hugo生成的要搜索的json数据手动同步到 Algolia比较麻烦，所以研究了下继续使用 GitHub Actions，这样在上面一系列操作后面添加即可。 引用库来自： https://github.com/chrisdmacrae/atomic-algolia 贴一下代码，在上面的 yml配置文件中后面跟着添加 - name:UseNode.jsuses:actions/setup-node@v1with:node-version:'12.x'- name:Installautomic-algoliarun:| npm install atomic-algolianpmrunalgoliaenv:ALGOLIA_APP_ID:${{secrets.ALGOLIA_APP_ID}}ALGOLIA_ADMIN_KEY:${{secrets.ALGOLIA_ADMIN_KEY}}ALGOLIA_INDEX_NAME:${{secrets.ALGOLIA_INDEX_NAME}}ALGOLIA_INDEX_FILE:\"./public/index.json\" 技巧 其中的 ALGOLIA_ADMIN_KEY 是ADMIN_KEY，而不是SEARCH_KEY ALGOLIA_INDEX_FILE 这里写自己GitHub仓库中相对要上传的文件的地址 完美执行img \" 完美执行 2020/09/016补充 放弃SCP，使用RSync 用了一段时间随着生成文件的越来越多，SCP是真的太慢了，在Github Actions 上我往往需要花费10多分钟才能完成部署 用到的Rsync库是 https://github.com/marketplace/actions/rsyncer-action，配置的一些参数看给出的文档就可以 这里贴出来我重新配置的yml 技巧 这次为了几乎很快的部署衔接，显示同步了文件，后来才去执行脚本删除，之前那种会因为先删除，而由于没有同步完成文件，网站处于无法访问的情况，当然那是出现在SCP中，经测试，Rsync还是很让我满意的 # This is a basic workflow to help you get started with Actionsname:CIon:push:branches:[master]jobs:build:runs-on:ubuntu-lateststeps:- name:CheckOutuses:actions/checkout@v2- name:rsyncdeploymentsuses:Pendect/action-rsyncer@v1.1.0env:DEPLOY_KEY:${{secrets.ALIYUN_KEY}}with:flags:'-avzr --delete'src:'public/'dest:'${{ secrets.ALIYUN_USER }}@${{ secrets.ALIYUN_HOST }}:${{ secrets.ALIYUN_PATH }}'- name:SSHRemoteCommandsuses:appleboy/ssh-action@masterwith:host:${{secrets.ALIYUN_HOST}}username:${{secrets.ALIYUN_USER}}password:${{secrets.ALIYUN_PASSWORD}}script:bash/root/blog_develop.sh- name:UseNode.jsuses:actions/setup-node@v1with:node-version:'12.x'- name:Installautomic-algoliarun:| npm install atomic-algolianpmrunalgoliaenv:ALGOLIA_APP_ID:${{secrets.ALGOLIA_APP_ID}}ALGOLIA_ADMIN_KEY:${{secrets.ALGOLIA_ADMIN_KEY}}ALGOLIA_INDEX_NAME:${{secrets.ALGOLIA_INDEX_NAME}}ALGOLIA_INDEX_FILE:\"./public/index.json\" 需要用到的 blog_develop.sh # 删除项目目录 if [ ! -d \"远端目录\" ]; then echo \"原项目文件不存在\" else rm -rf 远端目录 fi if [ ! -d \"新的临时文件目录，比如 远端目录temp\" ]; then echo \"临时项目文件不存在\" else # 重命名文件夹 mv 远端目录temp 远端目录 fi echo \"publish success!\" 效果图img \" 效果图 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:6:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"结束 至此，每次只需要在本地写文章并推送到GitHub，其他的事情就交给GitHub Actions做就可以了 ","date":"2020-08-30","objectID":"/hugo-github-actions-aliyun/:7:0","tags":["Hugo","GitHub Actions"],"title":"使用GitHub Actions部署Hugo到阿里云","uri":"/hugo-github-actions-aliyun/"},{"categories":["Tips"],"content":"周末整理了一下Git常用命令速查表，虽然现在有可视化的工具帮助，但是基础命令要知道","date":"2020-07-05","objectID":"/git-command-quick-check/","tags":["Git"],"title":"Git常用命令速查表","uri":"/git-command-quick-check/"},{"categories":["Tips"],"content":" 周末整理了一下Git常用命令速查表，虽然现在有可视化的工具帮助，但是基础命令要知道 Git Cheat Sheetmark \" Git Cheat Sheet ","date":"2020-07-05","objectID":"/git-command-quick-check/:0:0","tags":["Git"],"title":"Git常用命令速查表","uri":"/git-command-quick-check/"},{"categories":["Tips"],"content":"遇到的问题 git 出现old mode 100644 new mode 100755 在当前目录打开git，输入代码 `git config --add core.filemode false` ","date":"2020-07-05","objectID":"/git-command-quick-check/:1:0","tags":["Git"],"title":"Git常用命令速查表","uri":"/git-command-quick-check/"},{"categories":null,"content":"简介 男，98年双鱼座死宅，吾辈愚钝身无长物，仅所依凭，唯手熟耳。 职业：Gopher🐒。 描述：中度强迫症，重度急性子 常用昵称：Yqchilde Gayhub：https://github.com/yqchilde ","date":"2020-05-20","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Hey ","date":"2020-05-20","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"有趣的工具 CheckInAssistant：https://github.com/yqchilde/CheckInAssistant🤡是我参加山东省大学生软件设计大赛一等奖作品，也是我毕设答辩优秀作品 短链生成(t.cn)：(放弃维护) 科学上✈：(放弃维护) ","date":"2020-05-20","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"感谢 本来是想着从wordpress主题迁移到hugo的，已经迁移了一部分，加上复习时间紧，在github发现了该主题，感谢主题作者（不愧是loveit😀 ），这让我的心沉淀了下来，安心去思考其他事情。 ","date":"2020-05-20","objectID":"/about/:0:4","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"关于Rebirth WordPress的Rebirth主题我已不维，已转Hugo，大爱Hugo ","date":"2020-05-20","objectID":"/about/:0:5","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"联系 yqchilde@gmail.com 大多数在线，有事请联系 ","date":"2020-05-20","objectID":"/about/:0:6","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"声明 本博客所有内容采用知识共享署名-非商业性使用-相同方式共享4.0 国际许可协议进行许可。 ","date":"2020-05-20","objectID":"/about/:0:7","tags":null,"title":"关于我","uri":"/about/"},{"categories":["Golang"],"content":"Golang解析Json数组的一些技巧，奇怪的知识又增加了！","date":"2020-05-16","objectID":"/golang-json-serialization/","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"普通序列化 type A struct { Name string `json:\"name\"` Age int `json:\"age\"` Sex string `json:\"sex\"` } func main() { a := \u0026A{ Name: \"张三\", Age: 18, Sex: \"男\", } marshal, err := json.Marshal(a) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) } 输出结果：{\"name\":\"张三\",\"age\":18,\"sex\":\"男\"} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:1","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"忽略某个字段 如果想在序列化/反序列化的时候忽略掉结构体中的某个字段，可以在tag字段中添加- type A struct { Name string `json:\"name\"` Age int `json:\"-\"` Sex string `json:\"-\"` } func main() { a := \u0026A{ Name: \"张三\", Age: 18, Sex: \"男\", } marshal, err := json.Marshal(a) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) } 输出结果：{\"name\":\"张三\"} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:2","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"忽略空值字段 当struct中的字段没有值时，json.Marshal()序列化的时候不会忽略这些字段，而是输出默认字段的类型零值，如果想要忽略掉这些值的字段时，可以在对应字段添加omitemptytag type User struct { Name string `json:\"name\"` Email string `json:\"email\"` Hobby []string `json:\"hobby\"` } func main() { a := \u0026User{ Name: \"张三\", } marshal, err := json.Marshal(a) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) } 输出结果：{\"name\":\"张三\",\"email\":\"\",\"hobby\":null} 添加omitemptytag，看看效果 type User struct { Name string `json:\"name\"` Email string `json:\"email,omitempty\"` Hobby []string `json:\"hobby,omitempty\"` } 输出结果：{\"name\":\"张三\"} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:3","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"忽略嵌套结构体空值字段 type User struct { Name string `json:\"name\"` Email string `json:\"email,omitempty\"` Hobby []string `json:\"hobby,omitempty\"` Profile } type Profile struct { Website string `json:\"site\"` SLogan string `json:\"slogan\"` } func main() { a := \u0026User{ Name: \"张三\", Hobby: []string{\"足球\", \"双色球\"}, } marshal, err := json.Marshal(a) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) } 匿名嵌套Profile时序列化后的json串为单层的： {\"name\":\"张三\",\"hobby\":[\"足球\",\"双色球\"],\"site\":\"\",\"slogan\":\"\"} 想要变成嵌套的json串，需要改为具名嵌套或定义字段tag type User struct { Name string `json:\"name\"` Email string `json:\"email,omitempty\"` Hobby []string `json:\"hobby,omitempty\"` Profile `json:\"profile\"` } {\"name\":\"张三\",\"hobby\":[\"足球\",\"双色球\"],\"profile\":{\"site\":\"\",\"slogan\":\"\"}} 想要在嵌套的结构体为空值时，忽略该字段，仅添加omitempty是不够的，例如给Profile添加tagomitempty type User struct { Name string `json:\"name\"` Email string `json:\"email,omitempty\"` Hobby []string `json:\"hobby,omitempty\"` Profile `json:\"profile,omitempty\"` } 输出仍然是{\"name\":\"张三\",\"hobby\":[\"足球\",\"双色球\"],\"profile\":{\"site\":\"\",\"slogan\":\"\"}} 这时候换成指针就可以了 type User struct { Name string `json:\"name\"` Email string `json:\"email,omitempty\"` Hobby []string `json:\"hobby,omitempty\"` *Profile `json:\"profile,omitempty\"` } 输出结果变为{\"name\":\"张三\",\"hobby\":[\"足球\",\"双色球\"]} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:4","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"不修改原结构体忽略空值字段 现在有一个案例，需要json序列化User，但是不想把密码也序列化，又不想修改User结构体，这个时候我们就可以使用创建另外一个结构体PublicUser匿名嵌套原User，同时指定Password字段为匿名结构体指针类型，并添加omitemptytag，示例如下 type User struct { Name string `json:\"name\"` Password string `json:\"password\"` } type PublicUser struct { *User // 匿名嵌套 Password *struct{} `json:\"password,omitempty\"` } func main() { a := \u0026User{ Name: \"张三\", Password: \"123456\", } marshal, err := json.Marshal(PublicUser{ User: a, }) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) } 输出结果：{\"name\":\"张三\"}，理解为于引用类型引用 ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:5","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"优雅处理字符串格式的数字 有时候，前端传递来的json数据中可能会使用字符串类型的数字，这个时候可以在结构体tag中添加string来告诉json包从字符串中解析相应字段的数据 type Card struct { ID int64 `json:\"id,string\"` Score float64 `json:\"score,string\"` } func main() { jsonStr := `{\"id\":\"123456\",\"score\":\"88.50\"}` var c1 Card err := json.Unmarshal([]byte(jsonStr), \u0026c1) if err != nil { fmt.Println(err) return } fmt.Println(c1) } ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:6","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"整数变成浮点数 在JSON协议中是没有整形和浮点型之分的，他们统称为number，json字符串中的数字经过Go语言中的json包反序列化之后都会变成float64类型 func main() { var m = make(map[string]interface{}, 1) m[\"count\"] = 1 // int b, err := json.Marshal(m) if err != nil { fmt.Printf(\"marshal failed, err:%v\\n\", err) } fmt.Println(string(b)) // json string -\u003e map[string]interface{} var m2 map[string]interface{} err = json.Unmarshal(b, \u0026m2) if err != nil { fmt.Printf(\"unmarshal failed, err:%v\\n\", err) return } fmt.Printf(\"value:%v\\n\", m2[\"count\"]) // 1 fmt.Printf(\"type:%T\\n\", m2[\"count\"]) // float64 } 可以看到上面代码输出的结果，int数值类型变成了float64，如果想更合理的处理数字就需要使用decoder去反序列化 func main() { var m = make(map[string]interface{}, 1) m[\"count\"] = 1 // int b, err := json.Marshal(m) if err != nil { fmt.Println(err) } fmt.Println(string(b)) var m2 map[string]interface{} // 使用decoder方式反序列化，指定使用number类型 decoder := json.NewDecoder(bytes.NewReader(b)) decoder.UseNumber() err = decoder.Decode(\u0026m2) if err != nil { fmt.Println(err) return } fmt.Printf(\"value:%v\\n\", m2[\"count\"]) // 1 fmt.Printf(\"type:%T\\n\", m2[\"count\"]) // json.Number // 将m2[\"count\"]转为json.Number之后调用Int64()方法获得int64类型的值 count, err := m2[\"count\"].(json.Number).Int64() if err != nil { fmt.Printf(\"parse to int64 failed, err:%v\\n\", err) return } fmt.Printf(\"type:%T\\n\", int(count)) // int } json.Number的源码定义如下： // A Number represents a JSON number literal. // Number表示JSON数字文字 type Number string // String returns the literal text of the number. // 字符串返回数字的文字文本字符串返回数字的文字文本 func (n Number) String() string { return string(n) } // Float64 returns the number as a float64. // Float64将数字返回为float64 func (n Number) Float64() (float64, error) { return strconv.ParseFloat(string(n), 64) } // Int64 returns the number as an int64. // Int64将数字返回为int64 func (n Number) Int64() (int64, error) { return strconv.ParseInt(string(n), 10, 64) } 我们在处理number类型的json字段时需要得到json.Number类型，然后根据该字段的实际类型调用Float64()或Int64() ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:7","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"自定义解析时间字段 Go语言内置的json包使用RFC3339标准中定义的时间格式，对我们序列化时间字段的时候有很多限制 func main() { p1 := Post{CreateTime: time.Now()} marshal, err := json.Marshal(p1) if err != nil { fmt.Println(err) return } fmt.Println(string(marshal)) jsonStr := `{\"create_time\":\"2020-05-16 12:25:42\"}` var p2 Post if err := json.Unmarshal([]byte(jsonStr), \u0026p2); err != nil { fmt.Println(err) return } fmt.Println(p2) } 上面的代码输出结果如下： {\"create_time\":\"2020-05-16T21:23:48.1498199+08:00\"} parsing time \"\"2020-05-16 12:25:42\"\" as \"\"2006-01-02T15:04:05Z07:00\"\": cannot parse \" 12:25:42\"\" as \"T\" 这个报错说明json包不识别我们常用的字符串时间格式，如2020-05-16 12:25:42 不过我们通过实现json.Marshaler/json.Unmarshaler接口实现自定义的事件格式解析 实现decode包下的两个接口函数MarshalJSON和UnmarshalJSON，而且这个也可以作为实现自定义解析 func (ct *CustomTime) UnmarshalJSON(b []byte) (err error) { fmt.Println(string(b)) s := strings.Trim(string(b), \"\\\"\") if s == \"null\" { ct.Time = time.Time{} return } ct.Time, err = time.Parse(ctLayout, s) return } func (ct *CustomTime) MarshalJSON() ([]byte, error) { if ct.Time.UnixNano() == nilTime { return []byte(\"null\"), nil } return []byte(fmt.Sprintf(\"\\\"%s\\\"\", ct.Time.Format(ctLayout))), nil } ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:8","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"使用匿名结构体添加字段 使用内嵌结构体能够扩展结构体的字段，但有时候我们没有必要单独定义新的结构体，可以使用匿名结构体简化操作 type UserInfo struct { ID int `json:\"id\"` Name string `json:\"name\"` } func main() { u1 := UserInfo{ ID: 123456, Name: \"张三\", } // 使用匿名结构体内嵌User并添加额外字段Token b, err := json.Marshal(struct { *UserInfo Token string `json:\"token\"` }{ \u0026u1, \"91je3a4s72d1da96h\", }) if err != nil { fmt.Println(err) return } fmt.Println(string(b)) } 输出结果为：{\"id\":123456,\"name\":\"张三\",\"token\":\"91je3a4s72d1da96h\"} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:9","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"使用匿名结构体组合多个结构体 同理，也可以使用匿名结构体来组合多个结构体来序列化与反序列化数据 type Student struct { Name string `json:\"name\"` } type Teacher struct { Subject string `json:\"subject\"` } func main() { stu := Student{Name: \"张三\"} tea := Teacher{Subject: \"CS\"} // 使用匿名结构体内嵌User并添加额外字段Token b, err := json.Marshal(struct { *Student *Teacher }{ \u0026stu, \u0026tea, }) if err != nil { fmt.Println(err) return } fmt.Println(string(b)) } 输出结构为：{\"name\":\"张三\",\"subject\":\"CS\"} ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:10","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"gjson库 package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) const data string = `{\"good\":[{\"name\":\"chicken\"}]}` func main() { get := gjson.Get(data, \"good.#.name\") fmt.Println(get) } gjson的其他方法查看官方api就好 ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:11","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"参考链接 https://www.liwenzhou.com/posts/Go/json_tricks_in_go/ https://github/tidwall/gjson ","date":"2020-05-16","objectID":"/golang-json-serialization/:0:12","tags":["Golang"],"title":"Golang之json序列化","uri":"/golang-json-serialization/"},{"categories":["Golang"],"content":"Context包是什么很强大的包，他可用户web处理多个goroutine数据间关系，亦可处理超时控制和上下文控制，总之，要好好理解一下了。","date":"2020-05-15","objectID":"/golang-learning-context/","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":" 介绍一下 在go1.7之前，context还是非编制的，存在（golang.org/x/net/context）中，golang团队发现context这个东西很好用，于是把它收编了，1.7版本正式进入了标准库。专门用来简化处理多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作。 对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文，它们之间的函数调用链必须传递上下文，或者可以使用WithCancel、WithDeadline、WithTimeOut、WithValue创建的派生上下文，当一个上下文被取消时，它派生的所有上下文也被取消。 Context常用的使用姿势 web编程中，一个请求对应多个goroutine之间的数据交互 超时控制 上下文控制 ","date":"2020-05-15","objectID":"/golang-learning-context/:0:0","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"context的底层结构 type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } 字段 含义 Deadline 返回一个time.Time，表示当前Context应该结束的时间，也就是完成工作的截止时间，ok则表示有结束时间 Done 当Context被取消或者超时时候返回的一个close的channel，告诉给context的相关的函数要停止当前工作然后返回 Err context被取消的原因，它只会在Done返回的Channel被关闭时才会返回非空的值 Value 从context中返回键对应的值，对于同一个上下文来说，多次调用value会传入相同的key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据，context实现共享数据存储的地方，是线程安全的 ","date":"2020-05-15","objectID":"/golang-learning-context/:0:1","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"context的创建 为了更加方便的创建Context，包里头定义了Background来作为所有Context的根，可以认为所有的Context是树的结构，Background是树的根，当任一Context被取消的时候，那么继承他的Context将全部被回收。 ","date":"2020-05-15","objectID":"/golang-learning-context/:0:2","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"context的Api WithCancel WithCancel返回带有新Done通道的父节点的副本，当调用返回的cancel函数或当关闭 父上下文 的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) 练习场景： 在携程中依次循环计数，直到等于5的之后退出协程 func main() { ctx, cancel := context.WithCancel(context.Background()) // 当我们取完需要的整数后调用cancel defer cancel() // 从通道中读出 for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } } func gen(ctx context.Context) \u003c-chan int { dst := make(chan int) n := 1 go func() { for { select { // 用context结束掉，其实就是读取到空的struct case \u003c-ctx.Done(): return // return结束该goroutine，防止泄露 case dst \u003c- n: n++ } } }() return dst } **解释：**在上面的示例代码中，gen函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏。 WithDeadline WithDeadline返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) 取消上下文将释放与其相关联的资源，因此代码还应该在此上下文中运行的操作完成后立即调用cancel func main() { d := time.Now().Add(time.Millisecond * 500) ctx, cancel := context.WithDeadline(context.Background(), d) defer cancel() select { case \u003c-time.After(time.Second * 1): fmt.Println(\"overslept\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) // context deadline exceeded } } 上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用context.WithDeadline(context.Background(), d)得到一个上下文ctx和一个取消函数cancel，然后使用一个select让主程序陷入等待，等待1秒后打印overslept退出或者等待ctx过期后退出，因为ctx50秒后就过期，所以ctx.Done会先接收到值，上面的代码会打印ctx.Err()取消原因 WithTimeout WithTimeout返回WithDeadLine(parent, time.Now().Add(timeout)) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制 var wg sync.WaitGroup func main() { // 设置50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) defer cancel() wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) wg.Wait() fmt.Println(\"over\") } func worker(ctx context.Context) { LOOP: for { fmt.Println(\"db connecting ...\") // 假设连接数据库耗时10毫秒 time.Sleep(time.Millisecond * 10) select { case \u003c-ctx.Done(): break LOOP default: } } fmt.Println(\"worker done!\") wg.Done() } 上面示例代码就是设置了一个50毫秒的超时，在模拟链接超时到50毫秒的时候结束了操作 WithValue WithValue函数能够将请求作用域的数据与Context对象建立关系 func WithValue(parent Context, key, val interface{}) Context WithValue返回父节点的副本，其中与key关联的值为val 仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数 所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}，或者导出的上下文关键变量的静态类型应该为指针或接口。 type TraceCode string var wg sync.WaitGroup func main() { ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) defer cancel() ctx = context.WithValue(ctx, TraceCode(\"TRACE_CODE\"), \"12512312234\") wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) wg.Wait() fmt.Println(\"over\") } func worker(ctx context.Context) { key := TraceCode(\"TRACE_CODE\") // 在子goroutine中获取trace code traceCode, ok := ctx.Value(key).(string) if !ok { fmt.Println(\"invalid trace code\") } LOOP: for { fmt.Printf(\"worker, trace code:%s\\n\", traceCode) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case \u003c-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\"worker done!\") wg.Done() } ","date":"2020-05-15","objectID":"/golang-learning-context/:0:3","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"建议或注意事项 推荐以参数的方式传递context 如果是全链路函数，应该把context设置为第一个参数 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO() Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数 Context是线程安全的，可以放心的在多个goroutine中传递 ","date":"2020-05-15","objectID":"/golang-learning-context/:0:4","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"参考资料 李文周博客 由浅入深聊聊Golang的context ","date":"2020-05-15","objectID":"/golang-learning-context/:0:5","tags":["Golang"],"title":"Golang之学习Context","uri":"/golang-learning-context/"},{"categories":["Golang"],"content":"写了很久的slice却没有去想过他的扩容机制，近期面试，去了解了一下，这次也算是彻底明白了，之前只是简单的看了看文章","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["Golang"],"content":"Sliceimg \" Slice 写了很久的slice却没有去想过他的扩容机制，近期面试，去了解了一下，这次也算是彻底明白了，之前只是简单的看了看文章 ","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/:0:0","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["Golang"],"content":"STEP1 预估扩容后容量 先看一个例子 ints := []int{1, 2} ----\u003e 扩容前容量 oldCap = 2 ints = append(ints, 3, 4, 5) ----\u003e 至少扩容到 cap = 5 ? 了解一下预估规则 在原容量扩大两倍还要小于扩容后的容量时，预估容量就是扩容后的 当大于扩容后的时，如果小于1024时，预估容量是扩容前容量的2倍 当大于扩容后的时，如果大于1024时，预估容量是扩容前容量的1.25倍，即以0.25增加 扩容规则image-20200508232208435 \" 扩容规则 ","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/:0:1","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["Golang"],"content":"STEP2 需要多大内存 所需内存 = 预估容量 * 元素类型大小 这里以int 举例，int在64位操作上默认是int64，即8个字节，所以元素类型不一样，内存也不一样 内存这里需要了解golang的内存管理模块，源码在runtime/sizeclasses.go // class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87.50% // 2 16 8192 512 0 43.75% // 3 32 8192 256 0 46.88% // 4 48 8192 170 32 31.52% ... // 17 256 8192 32 0 5.86% // 18 288 8192 28 128 12.16% // 19 320 8192 25 192 11.80% // 20 352 8192 23 96 9.88% // 21 384 8192 21 128 9.51% // 22 416 8192 19 288 10.71% // 23 448 8192 18 128 8.37% // 24 480 8192 17 32 6.82% // 25 512 8192 16 0 6.05% ... // 66 32768 32768 1 0 12.50% 通过阅读源码可以知道，在小于16字节时，每次以8个字节增加，当大于16小于2^8时，每次以16字节增加，当大于2^8小于2^9时以32字节增加，依此规律… 申请内存时，选择相近的，且大于等于需要的大小 ","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/:0:2","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["Golang"],"content":"STEP3 匹配到合适的内存规格 在之前的例子中，预估容量为5 1个int是8个字节，5 * 8 = 40 最合适的内存规格是48，所以48 / 8 = 6 所以内存会扩容到 6 个容量 ","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/:0:3","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["Golang"],"content":"Practice 下面代码输出什么？ package main import \"fmt\" func main() { a := make([]int, 20) b := make([]int, 42) a = append(a, b...) fmt.Println(len(a), cap(a)) } 长度是62，这无疑，重点是容量计算，两倍的旧容量小于预估计的容量，所以预估计容量成了62 62 * 8 = 496，在内存规格中选择到了512，所以512 / 8 = 64，即cap(a) = 64 ","date":"2020-05-08","objectID":"/golang-slice-expand-capacity/:0:4","tags":["Golang"],"title":"终于理解了Slice扩容机制","uri":"/golang-slice-expand-capacity/"},{"categories":["MySQL"],"content":"假设现在学校目前只开设了语文、数学、英语三门课，后期还可开设其他门课，请尽量合理的设计班级、学生、考生成绩的数据库表结构并写出查询语句。","date":"2020-05-08","objectID":"/mysql-score-exercises/","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"题目 假设现在学校目前只开设了语文、数学、英语三门课，后期还可开设其他门课，请尽量合理的设计班级、学生、考生成绩的数据库表结构并写出查询语句。 数据库类图如下： 类图image-20200508171438084 \" 类图 设计的sql如下： /* Navicat Premium Data Transfer Source Server : root Source Server Type : MySQL Source Server Version : 50726 Source Host : localhost:3306 Source Schema : xuexiao Target Server Type : MySQL Target Server Version : 50726 File Encoding : 65001 Date: 08/05/2020 16:30:45 */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for t_class -- ---------------------------- DROP TABLE IF EXISTS `t_class`; CREATE TABLE `t_class` ( `classid` int(10) NOT NULL, `classname` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`classid`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of t_class -- ---------------------------- INSERT INTO `t_class` VALUES (1701, '一班'); INSERT INTO `t_class` VALUES (1702, '二班'); INSERT INTO `t_class` VALUES (1703, '三班'); -- ---------------------------- -- Table structure for t_course -- ---------------------------- DROP TABLE IF EXISTS `t_course`; CREATE TABLE `t_course` ( `cid` int(10) NOT NULL, `cname` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`cid`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of t_course -- ---------------------------- INSERT INTO `t_course` VALUES (101, 'MySQL'); INSERT INTO `t_course` VALUES (102, '网络'); INSERT INTO `t_course` VALUES (103, '系统'); -- ---------------------------- -- Table structure for t_score -- ---------------------------- DROP TABLE IF EXISTS `t_score`; CREATE TABLE `t_score` ( `sid` int(10) NULL DEFAULT NULL, `cid` int(10) NULL DEFAULT NULL, `score` int(3) NULL DEFAULT NULL, INDEX `s_id`(`sid`) USING BTREE, INDEX `c_id`(`cid`) USING BTREE, CONSTRAINT `c_id` FOREIGN KEY (`cid`) REFERENCES `t_course` (`cid`) ON DELETE NO ACTION ON UPDATE CASCADE, CONSTRAINT `s_id` FOREIGN KEY (`sid`) REFERENCES `t_student` (`sid`) ON DELETE NO ACTION ON UPDATE CASCADE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of t_score -- ---------------------------- INSERT INTO `t_score` VALUES (10001, 101, 59); INSERT INTO `t_score` VALUES (10001, 102, 66); INSERT INTO `t_score` VALUES (10001, 103, 80); INSERT INTO `t_score` VALUES (10002, 101, 79); INSERT INTO `t_score` VALUES (10002, 102, 50); INSERT INTO `t_score` VALUES (10002, 103, 82); INSERT INTO `t_score` VALUES (10003, 101, 30); INSERT INTO `t_score` VALUES (10003, 102, 84); INSERT INTO `t_score` VALUES (10003, 103, 65); -- ---------------------------- -- Table structure for t_student -- ---------------------------- DROP TABLE IF EXISTS `t_student`; CREATE TABLE `t_student` ( `sid` int(10) NOT NULL, `sname` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `classid` int(10) NULL DEFAULT NULL, PRIMARY KEY (`sid`) USING BTREE, INDEX `class_id`(`classid`) USING BTREE, CONSTRAINT `class_id` FOREIGN KEY (`classid`) REFERENCES `t_class` (`classid`) ON DELETE NO ACTION ON UPDATE CASCADE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of t_student -- ---------------------------- INSERT INTO `t_student` VALUES (10001, '张三', 1701); INSERT INTO `t_student` VALUES (10002, '李四', 1701); INSERT INTO `t_student` VALUES (10003, '王五', 1702); INSERT INTO `t_student` VALUES (10004, '赵六', 1702); INSERT INTO `t_student` VALUES (10005, '孙七', 1703); INSERT INTO `t_student` VALUES (10006, '王八', 1703); SET FOREIGN_KEY_CHECKS = 1; ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:1","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"题目一 统计每个学生成绩和选课数量以及所属班级 SELECT d.classid, a.sid, a.sname, SUM( c.score ) totalScore, COUNT( c.cid ) courseNum FROM t_student a, t_course b, t_score c, t_class d WHERE a.sid = c.sid AND b.cid = c.cid AND a.classid = d.classid GROUP BY a.sid 查询结果： classid sid sname totalScore courseNum 1701 10001 张三 205 3 1701 10002 李四 211 3 1702 10003 王五 179 3 ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:2","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"题目二 统计每个班总成绩在180分以上的学生信息 SELECT d.classid, a.sid, a.sname, SUM( c.score ) totalScore FROM t_student a, t_course b, t_score c, t_class d WHERE a.sid = c.sid AND b.cid = c.cid AND a.classid = d.classid GROUP BY a.sid HAVING ( SUM( c.score ) \u003e 180 ) 查询结果： classid sid sname totalScore 1701 10001 张三 205 1701 10002 李四 211 ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:3","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"题目三 统计各个班总成绩在180分以上的学生的数量 SELECT e.classid, COUNT( classid ) stuNum FROM ( SELECT bj.classid, xs.sid, SUM( cj.score ) totalScore FROM t_student xs, t_course kc, t_score cj, t_class bj WHERE xs.sid = cj.sid AND kc.cid = cj.cid AND xs.classid = bj.classid GROUP BY xs.sid HAVING ( totalScore \u003e 180 ) ) e classid stuNum 1701 2 ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:4","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"题目四 统计各个班成绩最高的学生姓名，总成绩 SELECT e.classid, stu.sname, MAX(e.totalScore) maxScore FROM t_student stu INNER JOIN ( SELECT bj.classid, xs.sid, SUM( cj.score ) totalScore FROM t_student xs, t_course kc, t_score cj, t_class bj WHERE xs.sid = cj.sid AND kc.cid = cj.cid AND xs.classid = bj.classid GROUP BY xs.sid ) e ON stu.sid = e.sid GROUP BY classid classid sname maxScore 1701 张三 211 1702 王五 179 ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:5","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["MySQL"],"content":"1055错误坑 1055 - Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'd.sname' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 解决方法： 在MySQL安装目录找到my.ini，在mysqld下面添加如下代码： sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 重启mysql服务 net stop mysql net start mysql ","date":"2020-05-08","objectID":"/mysql-score-exercises/:0:6","tags":["MySQL"],"title":"MySQL常考学生成绩查询练习题","uri":"/mysql-score-exercises/"},{"categories":["Golang"],"content":"Golang复习软件设计模式，通过设计模式学习其设计思想，无他，唯手熟尔。","date":"2020-04-21","objectID":"/golang-design-pattern/","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"虽然设计模式存在于面向对象的语言中，Golang并不是一门OOP的语言，但是这并代表不能实现设计模式。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:0:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"六大原则 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"开闭原则 一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因变化、升级、和维护对原有代码进行修改，可能会引入错误，所以当软件需要变化时，通过扩展软件实体的行为来实现变化，而不是修改原有代码。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:1","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"里氏代换原则 任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。通俗的说就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:2","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"单一职责原则 一个类只负责一项职责。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:3","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"依赖倒置原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。通俗的说：多用抽象的接口来描述相同的动作，降低实现这个动作的人和物之前的耦合度。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:4","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"接口隔离原则 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:5","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"迪米特法则 一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 创建型 结构型 行为型 创建者模式 装饰者模式 迭代器模式 工厂模式 适配器模式 命令模式 抽象工厂模式 代理模式 责任链模式 单例模式 外观模式 观察者模式 ","date":"2020-04-21","objectID":"/golang-design-pattern/:1:6","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"创建型 ","date":"2020-04-21","objectID":"/golang-design-pattern/:2:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"创建者模式 wiki解释 创建者模式（也可称为生成器模式 / 建造模式），是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式的主要角色 Product：产品角色。它是包含多个组成部件的复杂对象和属性，是一个模型。 Builder：抽象建造者。它是一个包含创建产品各个子部件的抽象方法的接口或者抽象类，通常还包含一个返回复杂产品的方法 ，该方法一般是抽象并且返回值类型是产品角色（Product）。理解为它在调用生成方法。 ConcreteBuilder：具体建造者。实现 Builder 接口或者继承Builder 抽象类，完成复杂产品的各个部件的具体创建方法。 Director：指挥者。它调用建造者（Builder）中的部件构造与装配方法完成复杂对象的创建，不设计产品具体构建细节。 主要作用 用户不用关心对象的建造过程就可以创建复杂对象 方便用户创建很多类似或者有相同属性的对象 代码复用性高，且用封装性 Golang实现 package builder // 为创建一个Product对象的各个部件指定抽象接口 type Builder interface { Build() } // 实现Builder的接口以构造和装配该产品的各个部件 type ConcreteBuilder struct { built bool } // 构造一个使用Builder接口的对象 type Director struct { builder Builder } // 表示被构造的复杂对象 // ConcreteBuilder创建该产品的内部表示并定义它的装配过程 type Product struct { Build bool } // 实例化Director对象 func NewDirector(b Builder) Director { return Director{builder: b} } // 实例化ConcreteBuilder对象 func NewConcreteBuilder() ConcreteBuilder { return ConcreteBuilder{built: false} } // ConcreteBuilder实现了 Builder 接口的 Build 方法 func (c *ConcreteBuilder) Build() { c.built = true } // 构造了一个使用Builder接口的对象 func (d *Director) Construct() { d.builder.Build() } // 通过ConcreteBuilder 获取 Product 的结果 func (c *ConcreteBuilder) GetResult() Product { return Product{Build: c.built} } 单元测试 package builder import ( \"fmt\" \"testing\" ) func TestConcreteBuilder_GetResult(t *testing.T) { // 具体建造者，实现一个完成Builder接口的对象 builder := NewConcreteBuilder() // 指挥具体建造者操作 director := NewDirector(\u0026builder) // 指挥具体建造者去做建造工作 director.Construct() // 建造完成的结果 result := builder.GetResult() fmt.Println(result.Build) } // result === RUN TestConcreteBuilder_GetResult true --- PASS: TestConcreteBuilder_GetResult (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:2:1","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"工厂模式 简单工程模式 wiki解释 普通的工厂方法模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。然而，这种选择可能包含复杂的逻辑，这时，可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。这个工厂类不需要由每个具体产品实现一个自己的具体的工厂类。 白话理解 即单独创建一个单一的工厂类，只做相关的实现，避免复杂的创建过程 Golang实现 package simple_factory // 实现接口 type API interface { say(name string) string } type Chinese struct{} type English struct{} // 实现方法 func NewAPI(lang string) API { switch lang { case \"ch\": return \u0026Chinese{} case \"en\": return \u0026English{} default: return nil } } func (*Chinese) say(name string) string { return \"你好\" + name } func (*English) say(name string) string { return \"Hello\" + name } 单元测试 package simple_factory import ( \"fmt\" \"testing\" ) func TestNewAPI(t *testing.T) { apiCh := NewAPI(\"ch\") say1 := apiCh.say(\"张\") fmt.Println(say1) apiEn := NewAPI(\"en\") say2 := apiEn.say(\"Tom\") fmt.Println(say2) } // result === RUN TestNewAPI 你好张 HelloTom --- PASS: TestNewAPI (0.00s) PASS 复杂工厂模式 白话理解 当我们需要实现数据固定，实现不同操作的时候，就可以扩展操作来实现新加入的方法不影响之前的代码，就比如下面的代码，实现了一个接口，让接口实现设置、计算方法，设计一个减法工厂，使其实现减法，如果我们需要再实现一个加法工厂，只需要单独在创建一个加法的，在项目中，往往这些需要抽离在单独的文件中。 package factory type Operator interface { SetLeft(int) SetRight(int) Result() int } // factory pattern type OperatorFactory interface { Create() Operator } // operator base type OperatorBase struct { left, right int } // 赋值 func (o *OperatorBase) SetLeft(left int) { o.left = left } // 赋值 func (o *OperatorBase) SetRight(right int) { o.right = right } // 操作数 type SubOperator struct { *OperatorBase } // 减法工厂 type SubOperatorFactory struct{} // 实际操作 func (o SubOperator) Result() int { return o.left - o.right } func (o SubOperatorFactory) Create() Operator { return \u0026SubOperator{ \u0026OperatorBase{}, } } 单元测试 package factory import ( \"fmt\" \"testing\" ) func TestSubOperator_Result(t *testing.T) { var fac OperatorFactory fac = SubOperatorFactory{} op := fac.Create() op.SetLeft(10) op.SetRight(20) fmt.Println(op.Result()) } // result === RUN TestSubOperator_Result -10 --- PASS: TestSubOperator_Result (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:2:2","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"抽象工厂 ","date":"2020-04-21","objectID":"/golang-design-pattern/:2:3","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"结构型 ","date":"2020-04-21","objectID":"/golang-design-pattern/:3:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"装饰者模式 wiki解释 修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。 通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。 白话 做一个修饰方法，他的参数是要修饰的函数的参数，他的返回值是我们想要得到的结果，动态地给一个对象添加一些额外的职责。比如我们要实现一个记录每个函数执行时间的方法，如果我们手动在每个函数添加记录执行时间的函数，在函数很多的情况下，要花费大量时间且不易维护，所以就需要修饰模式来帮我们修饰一个方法，得到特定的结果。 Golang实现 package decorator import \"fmt\" // 定义一个组件接口带有一个计算属性 type Component interface { Calc(int) interface{} } // 定义一个计算正方形面积组件模型 type SquareAreaComponent struct{} // 计算面积 func (s *SquareAreaComponent) Calc(sideLen int) interface{} { return sideLen * sideLen } // 定义修饰器 type SignDecorator struct { component Component } // 实例修饰器 func WarpMulDecorator(c Component) Component { return \u0026SignDecorator{component: c} } // 用修饰器返回特定内容 func (d *SignDecorator) Calc(sideLen int) interface{} { return fmt.Sprintf(\"边长为 %v 的正方形面积为 %v\", sideLen, sideLen*sideLen) } 单元测试 package decorator import ( \"fmt\" \"testing\" ) func TestCall(t *testing.T) { // 普通方法 s := \u0026SquareAreaComponent{} ret := s.Calc(10) fmt.Println(ret) // 用修饰器调用 decorator := WarpMulDecorator(s) fmt.Println(decorator.Calc(10)) } // result === RUN TestCall 100 边长为 10 的正方形面积为 100 --- PASS: TestCall (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:3:1","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"行为型 ","date":"2020-04-21","objectID":"/golang-design-pattern/:4:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"迭代器模式 wiki解释 在面向对象的编程里，迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。他可以让用户透过特定的接口寻访容器中的每一个元素而不用了解底层的实现。 白话解释 推荐这篇文章，真的是白话解释 白话解释迭代器 Golang实现 package iterator type Iterator interface { Idx() int // 索引 Val() interface{} // 值 HasNext() bool // 是否还有下一个值 Next() // 下一个 } type ArrayIterator struct { array []interface{} index *int } // return idx func (a *ArrayIterator) Idx() *int { return a.index } // return val func (a *ArrayIterator) Val() interface{} { return a.array[*a.index] } // return is next func (a *ArrayIterator) HasNext() bool { return len(a.array) \u003e= *a.index+1 } // return next func (a *ArrayIterator) Next() { if a.HasNext() { *a.index++ } } 单元测试 package iterator import ( \"fmt\" \"testing\" ) func TestArrayIterator(t *testing.T) { arr := []interface{}{1, 3, 5, 7, 9} idx := 0 interator := ArrayIterator{array: arr, index: \u0026idx} for it := interator; it.HasNext(); it.Next() { idx, val := it.Idx(), it.Val().(int) for val != arr[*idx] { fmt.Println(\"err\") } fmt.Println(*idx, val) } } // result === RUN TestArrayIterator 0 1 1 3 2 5 3 7 4 9 --- PASS: TestArrayIterator (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:4:1","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"命令模式 wiki解释 在面向对象编程的范畴中，命令模式是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动及其参数封装起来，于是这些行动可以被： 重复多次 取消（如果该对象有实现的话） 取消后又再重做 Golang实现 package command import \"fmt\" // 定义一个Person，他有名字，他有动作且可以传递 type Person struct { name string cmd Command } // 定义一个动作，他有执行者的名字，有具体操作的方法 type Command struct { person *Person method func() } // 实例化动作 func NewCommand(p *Person, method func()) Command { return Command{ person: p, method: method, } } // execute func (c *Command) Execute() { c.method() } // 实例化Person func NewPerson(name string, cmd Command) Person { return Person{ name: name, cmd: cmd, } } func (p *Person) Buy() { fmt.Println(fmt.Sprintf(\"%s is buying\", p.name)) } func (p *Person) Cook() { fmt.Println(fmt.Sprintf(\"%s is cooking\", p.name)) p.cmd.Execute() } func (p *Person) Wash() { fmt.Println(fmt.Sprintf(\"%s is washing\", p.name)) p.cmd.Execute() } func (p *Person) Listen() { fmt.Println(fmt.Sprintf(\"%s is Listening\", p.name)) p.cmd.Execute() } func (p *Person) Talk() { fmt.Println(fmt.Sprintf(\"%s is Talking\", p.name)) p.cmd.Execute() } 单元测试 package command import \"testing\" func TestCommand_Execute(t *testing.T) { // 依次调用 zhangsan := NewPerson(\"zhangsan\", NewCommand(nil, nil)) lisi := NewPerson(\"lisi\", NewCommand(\u0026zhangsan, zhangsan.Buy)) wangwu := NewPerson(\"wangwu\", NewCommand(\u0026lisi, lisi.Cook)) zhaoliu := NewPerson(\"zhaoliu\", NewCommand(\u0026wangwu, wangwu.Listen)) sunqi := NewPerson(\"sunqi\", NewCommand(\u0026zhaoliu, zhaoliu.Wash)) sunqi.Talk() } // result === RUN TestCommand_Execute sunqi is Talking zhaoliu is washing wangwu is Listening lisi is cooking zhangsan is buying --- PASS: TestCommand_Execute (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:4:2","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"责任链模式 wiki解释 责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。 白话讲 我个人理解就是如果一件事情，多个人要去做，就比如请假来说，小于3天的班主任可以请，大于3天小于5天的级部主任可以请，大于5天小于10天的只能教务校长请，其他的不给请，在传统模式中写代码需要写一堆的if else if else，这会使得代码臃肿、耦合度高。那么就需要使用责任链模式，通过接口暴露出一个方法，每个人只需要做到方法里面的事即可，如果自己处理不了，那就交给上一级处理。 Golang实现 package Responsibillity_Chain import \"strconv\" // 定义一个接口 里面是处理方法 type Handler interface { Handler(handlerID int) string } // 这个处理方法有一些参数，例如执行者的名字，ID以及他可以管理的下级 type handler struct { name string next Handler handlerId int } // 实例化这个处理方法 func NewHandler(name string, next Handler, handlerID int) *handler { return \u0026handler{ name: name, next: next, handlerId: handlerID, } } // 定义处理方法 func (h *handler) Handler(handlerID int) string { // 如果是自己执行，是可以的 if h.handlerId == handlerID { return h.name + \" handled \" + strconv.Itoa(handlerID) } // 如果自己已经是一串责任链中的最后一个人，即代表后面没有，那就返回 if h.next == nil { return \"\" } // 否则就继续给下个人执行 return h.next.Handler(handlerID) } 单元测试 package Responsibillity_Chain import ( \"fmt\" \"testing\" ) func TestHandler_Handle(t *testing.T) { // 李四是大领导 张三是小领导 李四管着张三 zhangsan := NewHandler(\"zhangsan\", nil, 1) lisi := NewHandler(\"lisi\", zhangsan, 2) // 李四可以自己处理，当然也可以叫下级处理 task := lisi.Handler(2) //task := lisi.Handler(1) fmt.Println(task) // 张三只能处理自己的，处理不了的还需要给上级 task = zhangsan.Handler(1) fmt.Println(task) } // result === RUN TestHandler_Handle lisi handled 2 zhangsan handled 1 --- PASS: TestHandler_Handle (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:4:3","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"观察者模式 wiki解释 观察者模式是软件设计模式的一种，在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现，此种模式通常被用来实时事件处理系统。 白话 添加一个事件监听，可以用来监听改变转态等等 Golang实现 package Observer import ( \"fmt\" \"sync\" \"time\" ) // 定义事件，用于通知 type Event struct { Data int } // 定义观察者接口，通知回馈 type Observer interface { NotifyCallback(event Event) } // 定义主题接口，实现添加监听，移除监听，通知三个方法 type Subject interface { AddListener(observer Observer) RemoveListener(observer Observer) Notify(event Event) } // 确保观察者唯一 type eventObserver struct { ID int Time time.Time } // 方法体 type eventSubject struct { Observers sync.Map } // NotifyCallback func (e *eventObserver) NotifyCallback(event Event) { fmt.Printf(\"Recieved: %d after %v\\n\", event.Data, time.Since(e.Time)) } // AddListener func (e *eventSubject) AddListener(obs Observer) { e.Observers.Store(obs, struct{}{}) } // RemoveListener func (e *eventSubject) RemoveListener(obs Observer) { e.Observers.Delete(obs) } // Notify func (e *eventSubject) Notify(event Event) { // 范围依次调用映射中的每个键和值，如果f返回false，则range停止迭代 e.Observers.Range(func(key, value interface{}) bool { if key == nil { return false } key.(Observer).NotifyCallback(event) return true }) } // 输出fib序列数 func Fib(n int) chan int { out := make(chan int) go func() { defer close(out) for i, j := 0, 1; i \u003c n; i, j = i+j, i { out \u003c- i } }() return out } 单元测试 package Observer import ( \"sync\" \"testing\" \"time\" ) func TestFib(t *testing.T) { // 实例化主题对象 subject := eventSubject{Observers: sync.Map{}} // 绑定观察者ID obs1 := eventObserver{ID: 1, Time: time.Now()} obs2 := eventObserver{ID: 1, Time: time.Now()} // 添加监听 subject.AddListener(\u0026obs1) subject.AddListener(\u0026obs2) for k := range Fib(10) { subject.Notify(Event{Data: k}) } } // result === RUN TestFib Recieved: 0 after 0s Recieved: 0 after 0s Recieved: 1 after 0s Recieved: 1 after 0s Recieved: 1 after 0s Recieved: 1 after 0s Recieved: 2 after 0s Recieved: 2 after 0s Recieved: 3 after 0s Recieved: 3 after 0s Recieved: 5 after 962.3µs Recieved: 5 after 962.3µs Recieved: 8 after 962.3µs Recieved: 8 after 962.3µs --- PASS: TestFib (0.00s) PASS ","date":"2020-04-21","objectID":"/golang-design-pattern/:4:4","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"参考 WIKI百科 Bilibili github ","date":"2020-04-21","objectID":"/golang-design-pattern/:5:0","tags":["Golang"],"title":"Golang实现软件设计模式","uri":"/golang-design-pattern/"},{"categories":["Golang"],"content":"Golang实现进制计算两种方法，逐位计算和位操作，了解丰富的math/big包","date":"2020-04-02","objectID":"/golang-binary-calculation/","tags":["Golang"],"title":"Golang实现进制计算两种方法","uri":"/golang-binary-calculation/"},{"categories":["Golang"],"content":" 本文将以二进制计算作为例子实现 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2: 输入: a = \"1010\", b = \"1011\" 输出: \"10101\" ","date":"2020-04-02","objectID":"/golang-binary-calculation/:0:0","tags":["Golang"],"title":"Golang实现进制计算两种方法","uri":"/golang-binary-calculation/"},{"categories":["Golang"],"content":"逐位计算 解法一：逐位计算 func addBinary(a string, b string) string { m, n := len(a), len(b) if m \u003e n { return addBinary(b, a) } buf := make([]byte, n+1) carry := 0 // 从后往前依次算尾数结果 for i, j := n-1, m-1; i \u003e= 0; i-- { if j \u003e= 0 { carry += int(a[j] - '0') j-- } carry += int(b[i] - '0') // 判断进位 buf[i+1] = byte(carry%2 + '0') carry /= 2 } // 判断是否有进位 if carry == 0 { return string(buf[1:]) } buf[0] = '1' return string(buf) } ","date":"2020-04-02","objectID":"/golang-binary-calculation/:0:1","tags":["Golang"],"title":"Golang实现进制计算两种方法","uri":"/golang-binary-calculation/"},{"categories":["Golang"],"content":"位运算 XOR 操作得到两个数字无进位相加的结果。 图1\" 图1 进位和两个数字与操作结果左移一位对应。 图2\" 图2 首先计算两个数字的无进位相加结果和进位，然后计算无进位相加结果与进位之和。同理求和问题又可以转换成上一步，直到进位为 0 结束。 计算 把 aa 和 bb 转换成整型数字 xx 和 yy，xx 保存结果，yy 保存进位。 当进位不为 0：y != 0： 计算当前 xx 和 yy 的无进位相加结果：answer = x^y。 计算当前 xx 和 yy 的进位：carry = (x \u0026 y) « 1。 完成本次循环，更新 x = answer，y = carry。 返回 xx 的二进制形式。 位运算 运用支持库 math/big ，里面的大数计算 func addBinary(a string, b string) string { x, _ := new(big.Int).SetString(a, 2) y, _ := new(big.Int).SetString(b, 2) zero, _ := new(big.Int).SetString(\"0\", 2) // for y.Cmp(zero) != 0 { answer := new(big.Int).Xor(x, y) carry := x.And(x, y).Lsh(x, 1) x, y = answer, carry } return fmt.Sprintf(\"%b\", x) } ","date":"2020-04-02","objectID":"/golang-binary-calculation/:0:2","tags":["Golang"],"title":"Golang实现进制计算两种方法","uri":"/golang-binary-calculation/"},{"categories":["Golang"],"content":"复习数据结构，使用Golang写一下","date":"2020-03-31","objectID":"/golang-data-structure/","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":" 复习，慢慢写吧。。。 ","date":"2020-03-31","objectID":"/golang-data-structure/:0:0","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"排序 ","date":"2020-03-31","objectID":"/golang-data-structure/:1:0","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"选择排序 每次选择数据中最小的数放在开头，这样经过若干个步骤，就排完了整个数组。 算法思想 贪心算法：每一次决策只看当前，当前最优则全局最优。(不是任何时候都适用) 减治思想：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。 优点 交换次数最少 复杂度分析 时间复杂度：O(N²)，这里N是数组的长度 空间复杂度：O(1)，使用到常数个临时变量 func selectionSort(arr []int) []int { var min = 0 for i := 0; i \u003c len(arr); i++ { min = i for j := i+1; j \u003c len(arr); j++ { if arr[j] \u003c arr[min] { min = j } } arr[i], arr[min] = arr[min], arr[i] } return arr } ","date":"2020-03-31","objectID":"/golang-data-structure/:1:1","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"冒泡排序 外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾； 特点： 在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。 复杂度分析： 时间复杂度：O(N²)，这里 N 是数组的长度； 空间复杂度：O(1)，使用到常数个临时变量。 func bubbleSort(arr []int) []int { for i := len(arr); i \u003e= 0; i-- { // 用bool标记是否已经有序，减少时间空间 isSorted := false for j := 0; j \u003c i; j++ { if j+1 \u003c len(arr) \u0026\u0026 arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] isSorted = false } } if isSorted { break } } return arr } ","date":"2020-03-31","objectID":"/golang-data-structure/:1:2","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"计数排序 计数排序是非比较排序，其适用于一定范围内的整数排序。在取值范围不是很大的情况下，它的性能甚至快过那些时间复杂度O(nlogn)的排序。 局限性 当数列最大和最小值差距过大时，并不适合用计数排序。 当数列元素不是整数时，也不适合用计数排序 初版 得到数列的最大值 根据最大值确定数组长度 遍历数列，填充统计数组 遍历统计数组，输出结果 func countSort(arr []int) []int { // 1. 得到数列的最大值 max := arr[0] for i := 1; i \u003c len(arr); i++ { if arr[i] \u003e max { max = arr[i] } } // 2. 根据最大值确定数组长度 countArray := make([]int, max+1) // 3. 遍历数列，填充统计数组 for i := 0; i \u003c len(arr); i++ { countArray[arr[i]]++ } // 4. 遍历统计数组，输出结果 sortedArray := make([]int, 0, len(arr)) for i := 0; i \u003c len(countArray); i++ { for j := 0; j \u003c countArray[i]; j++ { sortedArray = append(sortedArray, i) } } return sortedArray } 优化版 上面的算法并不是严谨，会浪费掉很多空间，比如数字是 90, 91, 95, 99, 93，那么最大的数字是99，会申请100个空间，但是前面0~89的空间就浪费了。 最大值-最小值=范围 逆序排列便于排名 func countSort(arr []int) []int { // 1. 得到数列的最大值和最小值，并计算差值d max, min := arr[0], arr[0] for i := 1; i \u003c len(arr); i++ { if arr[i] \u003e max { max = arr[i] } if arr[i] \u003c min { min = arr[i] } } d := max - min // 2. 创建统计数组并统计对应元素的个数 countArray := make([]int, d+1) for i := 0; i \u003c len(arr); i++ { countArray[arr[i]-min]++ } // 3. 统计数组做变量，后面的元素等于前面的元素之和 for i := 1; i \u003c len(countArray); i++ { countArray[i] += countArray[i-1] } // 4. 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组 sortedArray := make([]int, len(arr)) for i := len(arr)-1; i \u003e= 0; i-- { sortedArray[countArray[arr[i]-min]-1] = arr[i] countArray[arr[i]-min]-- } return sortedArray } ","date":"2020-03-31","objectID":"/golang-data-structure/:1:3","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"桶排序 桶排序是非比较排序，通过将元素划分到不同的区段，实现区段内排序进行操作 优点 将数据分到指定的桶，可以单独对桶内数据处理 缺点 如果数据分布不均匀，可能要浪费掉很多的空间， func bucketSort(arr []float64) []float64 { // 1. 得到数列的最大值和最小值，并计算差值d max, min := arr[0], arr[0] for i := 1; i \u003c len(arr); i++ { if arr[i] \u003e max { max = arr[i] } if arr[i] \u003c min { min = arr[i] } } // 2. 初始化桶 // 桶的大小 bucketSize := len(arr) // 桶的个数 bucketCount := int(max-min)/bucketSize + 1 sortedArray := make([][]float64, bucketCount) for i := 0; i \u003c bucketCount; i++ { sortedArray[i] = make([]float64, 0) } // 3. 将数据送入各自的桶 for _, val := range arr { idx := int(val-min) / bucketSize sortedArray[idx] = append(sortedArray[idx], val) } // 4. 每个桶内进行排序 sorted := make([]float64, 0) for _, bucket := range sortedArray { if len(bucket) \u003e 0 { // 插入排序 insertionSort(bucket) sorted = append(sorted, bucket...) } } return sorted } func insertionSort(arr []float64) { for k, v := range arr { temp := v j := k - 1 for ; j \u003e= 0 \u0026\u0026 arr[j] \u003e temp; j-- { arr[j+1] = arr[j] } arr[j+1] = temp } } ","date":"2020-03-31","objectID":"/golang-data-structure/:1:4","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"Stack 栈是具有有限容量的抽象数据类型，是一种LIFO(后进先出)数据结构。 package main import \"fmt\" type Stack struct { Size int Top *Node } type Node struct { Val string Next *Node } func (s *Stack) Len() int { return s.Size } func (s *Stack) Push(val string) { s.Top = \u0026Node{val, s.Top} fmt.Printf(\"%v pushed to stack\\n\", val) s.Size++ } func (s *Stack) Pop() (val string) { if s.Size \u003e 0 { val, s.Top = s.Top.Val, s.Top.Next s.Size-- return } return } func main() { stack := \u0026Stack{} stack.Push(\"10\") stack.Push(\"20\") stack.Push(\"30\") for stack.Len() \u003e 0 { fmt.Printf(\"%v poped from stack\\n\", stack.Pop()) } } ","date":"2020-03-31","objectID":"/golang-data-structure/:2:0","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"Queue 队列是一种抽象数据类型或线性数据结构，是FIFO(先进先出)数据结构。 package main import \"fmt\" type Queue struct { Size int Front *Node } type Node struct { Val string Next *Node } // len func (q *Queue) Length() int { return q.Size } // enqueue func (q *Queue) Enqueue(val string) { if q.Front == nil { q.Front = \u0026Node{val, nil} } else { rear := q.Front for rear.Next != nil { rear = rear.Next } rear.Next = \u0026Node{val, nil} } fmt.Printf(\"%v enqueued to queue\\n\", val) q.Size++ } // dequeue func (q *Queue) Dequeue() (val string) { if q.Size \u003e 0 { val, q.Front = q.Front.Val, q.Front.Next q.Size-- return } return } func main() { queue := \u0026Queue{} queue.Enqueue(\"10\") queue.Enqueue(\"20\") queue.Enqueue(\"30\") for queue.Length() \u003e 0 { fmt.Printf(\"%s poped from queue\\n\", queue.Dequeue()) } } ","date":"2020-03-31","objectID":"/golang-data-structure/:3:0","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"Linked List 练习了以下4个方法，对于链表平时刷题推荐用 container/list 这个包，很好用 pushFront 从头push pushBack 从尾push popFront 从头pop popBack 从尾pop type Node struct { Val int Next *Node } // head 默认值 var head *Node = nil // pushFront func (n *Node) pushFront(val int) *Node { if head == nil { n.Val = val n.Next = nil head = n return n } else { // 分配新内存空间 newNode := new(Node) newNode = head tmpNode := \u0026Node{ Val: val, Next: newNode, } head = tmpNode return head } } func (n *Node) pushBack(val int) *Node { if head == nil { n.Val = val n.Next = nil head = n return n } else { // 从链表中读取所有节点 for n.Next != nil { n = n.Next } // 分配新内存空间 n.Next = new(Node) n.Next.Val = val n.Next.Next = nil return n } } // popfront func (n *Node) popFront() *Node { if head == nil { return head } newNode := new(Node) newNode = head.Next head = newNode return head } // popback func (n *Node) popBack() *Node { if head == nil { return head } newNode := new(Node) newNode = head for newNode.Next.Next != nil { newNode = newNode.Next } newNode.Next = nil return head } ","date":"2020-03-31","objectID":"/golang-data-structure/:4:0","tags":["Golang","data structure"],"title":"Golang数据结构","uri":"/golang-data-structure/"},{"categories":["Golang"],"content":"Trie又称字典树，是N叉树的一种特殊形式。是一种存储大量字符串的树形数据结构，相当于`HashMap`，在存储单词中又比`HashMap`节省了很多的内存空间。`trie`树的根节点不存储内容，内容都在孩子节点上。","date":"2020-03-28","objectID":"/golang-trie/","tags":["Golang"],"title":"Golang之Trie写法 \u0026\u0026 sort.Interface使用","uri":"/golang-trie/"},{"categories":["Golang"],"content":"Trie Trie又称字典树，是N叉树的一种特殊形式。是一种存储大量字符串的树形数据结构，相当于HashMap，在存储单词中又比HashMap节省了很多的内存空间。trie树的根节点不存储内容，内容都在孩子节点上。 这是一个保存了8个单词的字典树的结构，8个单词分别是\"A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”。每条从根节点到叶子节点的路径都构成了单词（有的不需要走到叶子节点也是单词，比如i, in），从根节点出发的路径都是给定单词列表的某个/某些单词的前缀，反之如果在某个字符串中没有出现在这棵树的路径上，就说明组不成单词。 通常Trie树也会用在搜索引擎上，就是输入某些词，就会扩展出一些模糊词汇 Golang 实现的写法如下： type Trie struct { children [26]*Trie isWord bool } // Insert func (t *Trie) Insert(word string) { cur := t for k, v := range word { c := v - 'a' if cur.children[c] == nil { cur.children[c] = \u0026Trie{} } cur = cur.children[c] // end if k == len(word) -1 { cur.isWord = true } } } // Search func (t *Trie) Search(word string) bool { cur := t for _, v := range word { c := v - 'a' if cur.children[c] == nil { return false } cur = cur.children[c] } return cur.isWord } // StartWith func (t *Trie) StartWith(prefix string) bool { cur := t for _, v := range prefix { c := v - 'a' if cur.children[c] == nil { return false } cur = cur.children[c] } return true } func main() { trie := new(Trie) trie.Insert(\"inn\") fmt.Println(trie.Search(\"inn\")) // true fmt.Println(trie.Search(\"in\")) // false fmt.Println(trie.StartWith(\"in\")) // true fmt.Println(trie.StartWith(\"ia\")) // false } ","date":"2020-03-28","objectID":"/golang-trie/:0:1","tags":["Golang"],"title":"Golang之Trie写法 \u0026\u0026 sort.Interface使用","uri":"/golang-trie/"},{"categories":["Golang"],"content":"sort.Interface 关于自定义排序，用这个就可以了 在官方库sort.go中关于Interface定义如下： // A type, typically a collection, that satisfies sort.Interface can be // sorted by the routines in this package. The methods require that the // elements of the collection be enumerated by an integer index. type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } 所以我们只需要实现上面三个方法就可以了，如下是一个按照数组中字符串长度排序的一个例子 package main import ( \"fmt\" \"sort\" ) type MySliceSort []string func (m MySliceSort) Len() int { return len(m) } func (m MySliceSort) Less(i, j int) bool { return len(m[i]) \u003e len(m[j]) } func (m MySliceSort) Swap(i, j int) { m[i], m[j] = m[j], m[i] } func main() { sliceSort := MySliceSort{ \"这是五个字\", \"我要变六个字\", \"三个字\", } sort.Sort(sliceSort) fmt.Println(sliceSort) // [我要变六个字 这是五个字 三个字] } ","date":"2020-03-28","objectID":"/golang-trie/:0:2","tags":["Golang"],"title":"Golang之Trie写法 \u0026\u0026 sort.Interface使用","uri":"/golang-trie/"},{"categories":["Golang"],"content":"在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。","date":"2020-03-24","objectID":"/golang-duck-typing/","tags":["Golang"],"title":"Golang-Duck\u0026Typing","uri":"/golang-duck-typing/"},{"categories":["Golang"],"content":" 维基百科解释： 鸭子类型在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由\"当前方法和属性的集合\"决定。这个概念的名字来源于由詹姆斯·惠特科姆·莱利提出的鸭子测试，“鸭子测试”可以这样表述： 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为\"鸭子\"的对象，并调用它的\"走\"和\"叫\"方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的\"走\"和\"叫\"方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的\"走\"和\"叫\"方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。 鸭子类型通常得益于\"不\"测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。 在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。 按照我的理解 就是实现了 测试 是否实现了某个接口中的所有方法，代码如下 package main import \"fmt\" type Duck interface { Gaga() Swim() } func DuckSpeak(d Duck) { d.Gaga() } func DuckSwim(d Duck) { d.Swim() } type Bird struct { } func (b Bird) Gaga() { fmt.Println(\"Bird gaga~\") } func (b Bird) Swim() { fmt.Println(\"Bird Swim!\") } func main() { var bird Bird DuckSpeak(bird) // Bird gaga~ DuckSwim(bird) // Bird Swim! } ","date":"2020-03-24","objectID":"/golang-duck-typing/:0:0","tags":["Golang"],"title":"Golang-Duck\u0026Typing","uri":"/golang-duck-typing/"},{"categories":["Notes"],"content":"周末灌水，上午修补Valine-Admin，中午白嫖1Password，下午处理荣耀平板5的谷歌三件套，Valine-Admin: 不能每日邮件遗漏补发，原因：函数写半个？荣耀平板5最新系统9.1.0.175无法获取谷歌服务？","date":"2020-03-22","objectID":"/valine-admin-1password-google/","tags":["mood"],"title":"Valine-Admin、1Password、荣耀平板5谷歌三件套","uri":"/valine-admin-1password-google/"},{"categories":["Notes"],"content":" 周末灌水，上午修补Valine-Admin，中午白嫖1Password，下午处理荣耀平板5的谷歌三件套 Valine-Admin: 不能每日邮件遗漏补发，原因：函数写半个？ 荣耀平板5最新系统9.1.0.175无法获取谷歌服务，原因：贸易战 ","date":"2020-03-22","objectID":"/valine-admin-1password-google/:0:0","tags":["mood"],"title":"Valine-Admin、1Password、荣耀平板5谷歌三件套","uri":"/valine-admin-1password-google/"},{"categories":["Notes"],"content":"Valine-Admin 博客用的是Valine的三方评论，后台模板用的是zhaojun改完的Valine-Admin，基于免费版Leancloud账户的问题，每日最多运行18小时，所以在0-7点属于休眠状态，这个时刻如果有人评论了，虽然是会唤醒服务，但是是收不到邮件的，就需要邮件补发功能了，经过遗漏掉一条邮件排查掉，zhaojun fork panjunwen 的项目之后改完漏掉一个函数sendNotification，唉，fork了不要魔改啊，改的都丢三落四，整理完的 cloud.js 如下 const AV = require('leanengine'); const mail = require('./utilities/send-mail'); const Comment = AV.Object.extend('Comment'); const request = require('request'); function sendNotification(currentComment) { // 通知站长 mail.notice(currentComment); // AT评论通知 let pid = currentComment.get('pid'); if (!pid) { console.log(\"这条评论没有 @ 任何人\"); return; } // 通过被 @ 的评论 id, 则找到这条评论留下的邮箱并发送通知. let query = new AV.Query('Comment'); query.get(pid).then(function (parentComment) { if (parentComment.get('mail')) { mail.send(currentComment, parentComment); } else { console.log(currentComment.get('nick') + \" @ 了\" + parentComment.get('nick') + \", 但被 @ 的人没留邮箱... 无法通知\"); } }, function (error) { console.warn('好像 @ 了一个不存在的人!!!'); }); } AV.Cloud.afterSave('Comment', function (request) { let currentComment = request.object; return sendNotification(currentComment) }); AV.Cloud.define('resend_mails', function(req) { let query = new AV.Query(Comment); query.greaterThanOrEqualTo('createdAt', new Date(new Date().getTime() - 24*60*60*1000)); query.notEqualTo('isNotified', true); // 如果你的评论量很大，可以适当调高数量限制，最高1000 query.limit(200); return query.find().then(function(results) { new Promise((resolve, reject)=\u003e{ count = results.length; for (var i = 0; i \u003c results.length; i++ ) { sendNotification(results[i]); } resolve(count); }).then((count)=\u003e{ console.log(`昨日${count}条未成功发送的通知邮件处理完毕！`); }).catch((err)=\u003e{ console.log(err); }); }); }); AV.Cloud.define('self_wake', function(req) { request(process.env.ADMIN_URL, function (error, response, body) { console.log('自唤醒任务执行成功，响应状态码为:', response \u0026\u0026 response.statusCode); }); }) Leancloud免费服务的问题 总所周知，免费服务有限制，比如唤醒只给了15s时间，所以容易启动不了 解决办法：使用 linux 的 Crontab自行唤醒，即不用Leancloud定时任务唤醒，只用其补发邮件 ","date":"2020-03-22","objectID":"/valine-admin-1password-google/:0:1","tags":["mood"],"title":"Valine-Admin、1Password、荣耀平板5谷歌三件套","uri":"/valine-admin-1password-google/"},{"categories":["Notes"],"content":"白嫖1Password 看的某乎的教程直接添链接了，白嫖1Password ","date":"2020-03-22","objectID":"/valine-admin-1password-google/:0:2","tags":["mood"],"title":"Valine-Admin、1Password、荣耀平板5谷歌三件套","uri":"/valine-admin-1password-google/"},{"categories":["Notes"],"content":"荣耀平板5获取谷歌三件套 神奇操作 很神奇，可能是由于贸易战或者缓解原因，有的机型自带GMS，有的不带需要自己装，解决办法是花粉俱乐部参考得到的（即东拼西凑），以下是获取之前的配置 安卓9 Magic UI 2.1.0 版本号 9.1.0.175 方法 先通过华为手机助手降级到9.0.x.122，然后可以升级，升级到9.1.0.128😀必须128 安装谷歌服务方法（需PC辅助） 教程适用机型有：华为Mate30系列、华为畅享10Plus、华为nova5/nova5 Pro、华为novai/novai Pro、华为麦芒8、华为畅享9系列/Max等 荣耀9X、荣耀20i、荣耀8X/8X Max、荣耀10青春版等 荣耀平板5、华为平板M6等 助手是用来激活设备管理器的，只要激活了就行了，不用担心惊叹号那些问题。 步骤如下 下载并解压谷歌服务包 连接Hisuite（pc华为手机助手）点击数据恢复，找到刚才解压的文件，只恢复应用数据 恢复完成后，查看桌面是否有谷歌服务助手APP 打开谷歌服务助手，激活设备管理器 其他不用理会（感叹号的不用管，直接退出APP） 激活完成后重启手机，下载Go谷歌安装器，安装三件套，完成，如果可以打开谷歌play并可以登陆，那就恭喜了 咦~真香 所需工具 谷歌服务 提取码：9rvb Go谷歌安装器，酷安和豌豆荚都有 ","date":"2020-03-22","objectID":"/valine-admin-1password-google/:0:3","tags":["mood"],"title":"Valine-Admin、1Password、荣耀平板5谷歌三件套","uri":"/valine-admin-1password-google/"},{"categories":["Tips"],"content":"前提是需要先获得`wp-rocket`插件，该插件是收费插件，如果有能力请支持正版，这里不提供下载地址，擅于利用搜索引擎或万能的某宝。本文是基于自己用宝塔配置rocket-nginx的教程，因为网上目前搜到的所有配置都是直接翻译github的README.md( 😒 )，不过还是推荐看最新的文档，没准啥时候就变动了，操作步骤如下","date":"2020-03-08","objectID":"/wordpress-rocket/","tags":["WordPress"],"title":"正确配置rocket-nginx，加速你的wordpress","uri":"/wordpress-rocket/"},{"categories":["Tips"],"content":"0x01 前提 前提是需要先获得wp-rocket插件，该插件是收费插件，如果有能力请支持正版，这里不提供下载地址，擅于利用搜索引擎或万能的某宝。本文是基于自己用宝塔配置rocket-nginx的教程，因为网上目前搜到的所有配置都是直接翻译github的README.md(😒)，不过还是推荐看最新的文档，没准啥时候就变动了，操作步骤如下 ","date":"2020-03-08","objectID":"/wordpress-rocket/:0:1","tags":["WordPress"],"title":"正确配置rocket-nginx，加速你的wordpress","uri":"/wordpress-rocket/"},{"categories":["Tips"],"content":"0x02 正文 rocket-nginx 介绍一下（翻译过来）： Rocket-Nginx是WordPress缓存插件WP-Rocket的Nginx配置。它使Nginx可以直接提供以前缓存的文件，而无需调用WordPress或任何PHP。它还会添加标题以缓存CSS，JS和媒体，以通过减少对Web服务器的请求来利用浏览器的缓存。 简单说就是NGINX→PHP-FPM→PHP→静态文件 变成了 NGINX→静态文件（通过直接提供静态页面而不加载WordPress或PHP，可以使WP-Rocket更快。） github地址：rocket-nginx 禁止WP定时任务 在wp-config这个文件里添加一行代码，作用是为了禁止WP自带的CRON定时任务 define('DISABLE_WP_CRON', true); 添加新的定时任务 以下三种定时任务代码任一个就行，记得将website换成自己的网址 */15 * * * * wget -q -O - http://www.website.com/wp-cron.php?doing_wp_cron \u0026\u003e/dev/null or */15 * * * * curl http://www.website.com/wp-cron.php?doing_wp_cron \u0026\u003e/dev/null or */15 * * * * cd /home/user/public_html; php wp-cron.php \u0026\u003e/dev/null 在SSH添加定时任务，先去了解Crontab知识，点这里查看 有宝塔面板的可以直接在宝塔中添加定时任务，那就简单了 定时任务image-20200308183831086 \" 定时任务 拉取rocket-nginx到nginx目录 在SSH里面进入到nginx的目录，以宝塔为例（/www/server/nginx）cd /www/server/nginx 拉取代码 git clone https://github.com/satellitewp/rocket-nginx.git 从2.0版开始，必须生成配置。要生成默认配置，必须重命名禁用的ini文件并运行配置解析器： cd rocket-nginx cp rocket-nginx.ini.disabled rocket-nginx.ini php rocket-parser.php 运行之后就会在rocket-nginx目录生成一个default.conf文件，是根据rocket-nginx.ini对应解析的，所以可以看看相应配置 在nginx配置文档导入 在对应网站的nginx配置文档中server部分导入 server { ... # Rocket-Nginx configuration include /www/server/nginx/rocket-nginx/default.conf; ... } 配置完要先测试是否配置可行 nginx -t 配置可行记得重启nginx service nginx reload 测试是否生效 在rocket-nginx.ini 文件中将debug设置成true，这样就可以看到在请求的header里面有X-Rocket-Nginx开头的内容 X-Rocket-Nginx-Serving-Static：配置是否直接提供了缓存文件（是否绕过WordPress）：是或否 X-Rocket-Nginx-Reason：注明了为什么启用的原因，如果启用成功返回路径，失败返回原因 X-Rocket-Nginx-File：不管是否启用成功，这里展示一下代理的路径，方便拍错 ","date":"2020-03-08","objectID":"/wordpress-rocket/:0:2","tags":["WordPress"],"title":"正确配置rocket-nginx，加速你的wordpress","uri":"/wordpress-rocket/"},{"categories":["Tips"],"content":"0x03 注意 提示：每次更改了rocket-nginx.ini就要利用php rocket-parser.php 命令解析 记得关闭wp-rocket插件中的对移动端单独缓存功能，（除非你的主题开发了两端）我想现在的主题都是响应式的不存在这个问题 如果站点是https并且在header中显示如下内容，即结尾一直是/index.html，那就说明可能是你的nginx配置文件的问题，需要从自己的文档下手 X-Rocket-Nginx-Serving-Static：NO X-Rocket-Nginx-File：... /index.html 正确的路径结尾应该是 index-https.html_gzip，这是https站点的情况 ","date":"2020-03-08","objectID":"/wordpress-rocket/:0:3","tags":["WordPress"],"title":"正确配置rocket-nginx，加速你的wordpress","uri":"/wordpress-rocket/"},{"categories":["Tips"],"content":"0x04 效果 在没有做nginx优化时，即使用了wp-rocket插件也是两个B，现在明显有变化，因为本主题是图文式的，如果你的主题不怎么用图片，那么效果会更为显著。 速度测试image-20200308190851632 \" 速度测试 ","date":"2020-03-08","objectID":"/wordpress-rocket/:0:4","tags":["WordPress"],"title":"正确配置rocket-nginx，加速你的wordpress","uri":"/wordpress-rocket/"},{"categories":["Tips"],"content":"讲解了我制作的WordPress主题中logo为什么推荐使用svg图片","date":"2020-02-27","objectID":"/tips/848/","tags":["Rebirth"],"title":"Rebirth为什么推荐使用svg图片作为logo","uri":"/tips/848/"},{"categories":["Tips"],"content":"为了什么 本文是为了制作的wordpress主题rebirth的logo设置 主题 repo: Rebirth 使用了svg效果 效果图1\" 效果图1 效果图2\" 效果图2 我们可以看出来，效果就是在页面滑动之后会改变填充色，（并不是所有的svg图片都是，下面就说编辑方法） 制作方法 \u003csvg viewBox=\"0 0 1024 1024\" xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cg style=\"isolation:isolate\"\u003e \u003cg fill=\"#000000\"\u003e 这里放置你的 `path` 标签 \u003c/g\u003e \u003c/g\u003e \u003c/svg\u003e 举个栗子 去阿里icon矢量库，找一个图，并复制svg代码 矢量库图标\" 矢量库图标 \u003csvg t=\"1582799138465\" class=\"icon\" viewBox=\"0 0 1267 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"23300\" width=\"64\" height=\"64\"\u003e\u003cpath d=\"M318.82629556 133.78803087C-133.08757287 392.20264631 164.67345974 699.80401596 508.2092303 657.19988601c422.53471382 49.0598287 601.5273088-308.81087989 270.72125986-500.4436034-123.34018755-57.77029413-212.92358917-50.7173058-460.1041946-22.97074138z\" fill=\"#2c2c2c\" p-id=\"23301\"\u003e\u003c/path\u003e\u003cpath d=\"M214.90297937 222.368485l54.69674405-224.25466126 103.92331621 177.7631744zM701.6985288 197.75519893l106.65591319-194.16871362 62.89951436 322.70282623zM510.26241218 657.19988601s-16.41051715 257.07071626-51.96414705 281.68151403c-35.55114165 24.61328606 180.49826105 71.10477156 232.45991845 21.87820079 95.3621735-81.27610719-75.53217667-248.9600287-95.71805762-311.76497203-62.38435165-195.77392864-84.77771378 8.20525858-84.77771378 8.20525721z\" fill=\"#2c2c2c\" p-id=\"23302\"\u003e\u003c/path\u003e\u003cpath d=\"M687.54526663 901.81463786s148.42632737-11.95573548 201.76423982-119.54740309c53.34040074-107.58917793 20.87276364-193.66101849 32.47012538-227.13409135 11.59487344-33.47307423 67.25474708-167.36287878 201.76423983-90.85512978 134.50949276 76.51023728 122.91461933 188.88021755 62.61580129 217.57248946-60.29632977 28.68978363-166.02644443 25.01147914-97.40291128 0 66.2517982-24.14541025 151.23607471-66.54795404 55.65987362-150.62634235-73.5810334-64.72622317-102.08665291-65.3135569-160.02120218-14.34489113-69.96743372 61.55312413 36.17331813 214.64328419-97.40291126 334.72575757-123.36009791 110.89666592-204.086201 74.11610369-204.08619963 74.11610507z\" fill=\"#2c2c2c\" p-id=\"23303\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\" p-id=\"23304\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\" p-id=\"23305\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\" p-id=\"23306\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\" p-id=\"23307\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\" p-id=\"23308\"\u003e\u003c/path\u003e\u003c/svg\u003e 保留所有的 \u003cpath\u003e\u003c/path\u003e，并去掉 path 里面的 p-id 内容是这样 \u003cpath d=\"M318.82629556 133.78803087C-133.08757287 392.20264631 164.67345974 699.80401596 508.2092303 657.19988601c422.53471382 49.0598287 601.5273088-308.81087989 270.72125986-500.4436034-123.34018755-57.77029413-212.92358917-50.7173058-460.1041946-22.97074138z\" fill=\"#2c2c2c\"\u003e \u003c/path\u003e \u003cpath d=\"M214.90297937 222.368485l54.69674405-224.25466126 103.92331621 177.7631744zM701.6985288 197.75519893l106.65591319-194.16871362 62.89951436 322.70282623zM510.26241218 657.19988601s-16.41051715 257.07071626-51.96414705 281.68151403c-35.55114165 24.61328606 180.49826105 71.10477156 232.45991845 21.87820079 95.3621735-81.27610719-75.53217667-248.9600287-95.71805762-311.76497203-62.38435165-195.77392864-84.77771378 8.20525858-84.77771378 8.20525721z\" fill=\"#2c2c2c\"\u003e \u003c/path\u003e \u003cpath d=\"M687.54526663 901.81463786s148.42632737-11.95573548 201.76423982-119.54740309c53.34040074-107.58917793 20.87276364-193.66101849 32.47012538-227.13409135 11.59487344-33.47307423 67.25474708-167.36287878 201.76423983-90.85512978 134.50949276 76.51023728 122.91461933 188.88021755 62.61580129 217.57248946-60.29632977 28.68978363-166.02644443 25.01147914-97.40291128 0 66.2517982-24.14541025 151.23607471-66.54795404 55.65987362-150.62634235-73.5810334-64.72622317-102.08665291-65.3135569-160.02120218-14.34489113-69.96743372 61.55312413 36.17331813 214.64328419-97.40291126 334.72575757-123.36009791 110.89666592-204.086201 74.11610369-204.08619963 74.11610507z\" fill=\"#2c2c2c\"\u003e\u003c/path\u003e \u003cpath d=\"\" fill=\"#2c2c2c\"\u003e \u003c/path\u003e \u003cpath d=\"\" fill=\"#2c2c2c\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\"\u003e\u003c/path\u003e \u003cpath d=\"\" fill=\"#2c2c2c\"\u003e\u003c/path\u003e\u003cpath d=\"\" fill=\"#2c2c2c\"\u003e\u003c/path\u003e 将这段代码全部复制到上面那个代码块中就好了。 ","date":"2020-02-27","objectID":"/tips/848/:0:1","tags":["Rebirth"],"title":"Rebirth为什么推荐使用svg图片作为logo","uri":"/tips/848/"},{"categories":["Golang"],"content":"这个库烦了我两天，我能接触到的例子都是旧版的，新版简直就是大改版哦，构建函数简直和旧版出入太大，函数参数及返回值皆不一样，记录一下最新版的字符验证码的完整实例，（数字验证码、计算验证码、汉字验证码以及语音验证码构建方法举一反三）","date":"2020-02-07","objectID":"/golang-base64captcha/","tags":["Golang"],"title":"Golang验证码–base64Captcha库1.3.0版本构建实例","uri":"/golang-base64captcha/"},{"categories":["Golang"],"content":" 这个库烦了我两天，我能接触到的例子都是旧版的，新版简直就是大改版哦，构建函数简直和旧版出入太大，函数参数及返回值皆不一样，记录一下最新版的字符验证码的完整实例，（数字验证码、计算验证码、汉字验证码以及语音验证码构建方法举一反三） ","date":"2020-02-07","objectID":"/golang-base64captcha/:0:0","tags":["Golang"],"title":"Golang验证码–base64Captcha库1.3.0版本构建实例","uri":"/golang-base64captcha/"},{"categories":["Golang"],"content":"官方例子地址 在线构建验证码样式 注意: 旧版的base64Captcha.ConfigCharacte 以及 base64Captcha.GenerateCaptcha方法由于作者重构已经取消，具体实现看下面代码 ","date":"2020-02-07","objectID":"/golang-base64captcha/:0:1","tags":["Golang"],"title":"Golang验证码–base64Captcha库1.3.0版本构建实例","uri":"/golang-base64captcha/"},{"categories":["Golang"],"content":"代码如下 package tool import ( \"github.com/gin-gonic/gin\" \"github.com/mojocn/base64Captcha\" \"image/color\" ) type CaptchaResult struct { Id string `json:\"id\"` Base64Blob string `json:\"base_64_blob\"` VerifyValue string `json:\"code\"` } // 设置自带的store var store = base64Captcha.DefaultMemStore // 生成图形化验证码 func GenerateCaptcha(ctx *gin.Context) { var driver base64Captcha.Driver var driverString base64Captcha.DriverString // 配置验证码信息 captchaConfig := base64Captcha.DriverString{ Height: 30, Width: 60, NoiseCount: 0, ShowLineOptions: 2 | 4, Length: 4, Source: \"1234567890qwertyuioplkjhgfdsazxcvbnm\", BgColor: \u0026color.RGBA{ R: 3, G: 102, B: 214, A: 125, }, Fonts: []string{\"wqy-microhei.ttc\"}, } // 自定义配置，如果不需要自定义配置，则上面的结构体和下面这行代码不用写 driverString = captchaConfig driver = driverString.ConvertFonts() captcha := base64Captcha.NewCaptcha(driver, store) id, b64s, err := captcha.Generate() if err != nil { Failed(ctx, err.Error()) } captchaResult := CaptchaResult{ Id: id, Base64Blob: b64s, } Success(ctx, gin.H{ \"captcha_result\": captchaResult, }) } 这样子输出的就是一条json，放在项目里面就是这样的 效果图mark \" 效果图 ","date":"2020-02-07","objectID":"/golang-base64captcha/:0:2","tags":["Golang"],"title":"Golang验证码–base64Captcha库1.3.0版本构建实例","uri":"/golang-base64captcha/"},{"categories":["Tips"],"content":"可以不要引号，实测也可以，反而加了引号有些网站不能访问，不需要设置 https.proxy ，仅设置 http.proxy就可以了， 端口需要看本地的socks端口，不是固定","date":"2020-02-01","objectID":"/git-clone-slow/","tags":["Git"],"title":"Git设置代理解决git clone太慢的问题","uri":"/git-clone-slow/"},{"categories":["Tips"],"content":"设置代理 git config --global http.proxy socks5://domain:port // 栗子: git config --global http.proxy socks5://127.0.0.1:2081 注意点： 可以不要引号，实测也可以，反而加了引号有些网站不能访问 不需要设置 https.proxy ，仅设置 http.proxy就可以了 端口需要看本地的socks端口，不是固定 ","date":"2020-02-01","objectID":"/git-clone-slow/:0:1","tags":["Git"],"title":"Git设置代理解决git clone太慢的问题","uri":"/git-clone-slow/"},{"categories":["Tips"],"content":"取消代理 git config --global --unset http.proxy 查看代理 git config --global --get http.proxy ","date":"2020-02-01","objectID":"/git-clone-slow/:0:2","tags":["Git"],"title":"Git设置代理解决git clone太慢的问题","uri":"/git-clone-slow/"},{"categories":["Tips"],"content":"利用油猴脚本 + Aria RPC + Motrix批量下载哔哩哔哩视频","date":"2020-01-25","objectID":"/aria-rpc-motrix-bilibili/","tags":["Aria"],"title":"油猴脚本 + Aria RPC + Motrix批量下载哔哩哔哩视频","uri":"/aria-rpc-motrix-bilibili/"},{"categories":["Tips"],"content":"所需工具 脚本下载地址：Bilibili Evolved Motrix下载地址：Motrix ","date":"2020-01-25","objectID":"/aria-rpc-motrix-bilibili/:0:1","tags":["Aria"],"title":"油猴脚本 + Aria RPC + Motrix批量下载哔哩哔哩视频","uri":"/aria-rpc-motrix-bilibili/"},{"categories":["Tips"],"content":"操作步骤按图示 步骤一mark \" 步骤一 步骤二mark \" 步骤二 步骤三mark \" 步骤三 步骤四mark \" 步骤四 步骤五mark \" 步骤五 步骤六mark \" 步骤六 ","date":"2020-01-25","objectID":"/aria-rpc-motrix-bilibili/:0:2","tags":["Aria"],"title":"油猴脚本 + Aria RPC + Motrix批量下载哔哩哔哩视频","uri":"/aria-rpc-motrix-bilibili/"},{"categories":["Tips"],"content":"记录一下在Win10里配置Nginx并设置代理","date":"2020-01-11","objectID":"/windows-nginx/","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"下载nginx 点这里下载 ","date":"2020-01-11","objectID":"/windows-nginx/:0:1","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"解压到指定目录，文件夹内容如下 ","date":"2020-01-11","objectID":"/windows-nginx/:0:2","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"启动Nginx 查看是否成功运行（在任务管理器-\u003e详细信息中找到nginx进程） ","date":"2020-01-11","objectID":"/windows-nginx/:0:3","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"浏览器运行127.0.0.1查看 ","date":"2020-01-11","objectID":"/windows-nginx/:0:4","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"日志目录 成功日志 logs/access.log 错误日志logs/error.log nginx.pid（如果有nginx.pid文件，则说明nginx在运行） ","date":"2020-01-11","objectID":"/windows-nginx/:0:5","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"常用的命令 nginx.exe -s stop //停止nginx nginx.exe -s reload //重新加载nginx nginx.exe -s quit //退出nginx ","date":"2020-01-11","objectID":"/windows-nginx/:0:6","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"注意 以上的命令中，.exe可以去掉 强制停止nginx服务器，如果有未处理的数据，则会丢弃 nginx -s stop 优雅的停止nginx服务器，如果有未处理的数据，等待处理完成之后停止 nginx -s quit ","date":"2020-01-11","objectID":"/windows-nginx/:0:7","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"简单配置一个nginx反向代理 修改本地hosts文件，添加一个代理本地的域名 我们启用的是golang的服务，启动端口是8080端口，也就是127.0.0.1:8080，修改nginx配置，目录地址为conf/nginx.conf，删掉原来的server，进行重写server内容 server { listen 80; #要监听的端口（本地为80端口） server_name www.yubo.top; #域名（对应上面的hosts文件里面的域名） # location范围很广，/ 代表根目录 location / { proxy_pass http://127.0.0.1:8080; #要代理的ip地址 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #设置真实ip头 proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } #错误页面配置 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 重新加载nginx会发现生效了，访问www.yubo.top就可以代理到127.0.0.1:8080的内容了 ","date":"2020-01-11","objectID":"/windows-nginx/:0:8","tags":["Nginx"],"title":"win10配置nginx并设置反向代理","uri":"/windows-nginx/"},{"categories":["Tips"],"content":"简单来说就是装了之后能在cmd中通过一些代码实现华丽的效果，比如改变字体颜色","date":"2020-01-11","objectID":"/windows-cmd-ansi/","tags":["CMD","ANSI"],"title":"解决win10的cmd命令行不转义ANSI序列（让cmd输出彩色字体）","uri":"/windows-cmd-ansi/"},{"categories":["Tips"],"content":"什么是ANSI序列 ANSI转义序列是一种带内信号的转义序列标准，用于控制视频文本终端上的光标位置、颜色和其他选项。在文本中嵌入确定的字节序列，大部分以ESC转义字符和”[“字符开始，终端会把这些字节序列解释为相应的指令，而不是普通的字符编码。 ANSI序列是在二十世纪七十年代引入的标准，用以取代特定于终端供应商的序列，并在二十世纪八十年代早期开始在计算机设备市场上广泛使用。与早期缺少光标移动功能的系统相比，新生的电子公告板系统使用ANSI序列改进其显示。正是因为这个原因，ANSI序列变成了所有制造商共同采用的标准。 简单来说就是装了之后能在cmd中通过一些代码实现华丽的效果，比如改变字体颜色 ","date":"2020-01-11","objectID":"/windows-cmd-ansi/:0:1","tags":["CMD","ANSI"],"title":"解决win10的cmd命令行不转义ANSI序列（让cmd输出彩色字体）","uri":"/windows-cmd-ansi/"},{"categories":["Tips"],"content":"安装 从这里下载最新文件，解压 选择自己的电脑需要的配置 路径行输入cmd快捷进入当前路径下的cmd窗口 执行下面两行代码进行安装 ansicon.exe -i ansicon.exe -l ","date":"2020-01-11","objectID":"/windows-cmd-ansi/:0:2","tags":["CMD","ANSI"],"title":"解决win10的cmd命令行不转义ANSI序列（让cmd输出彩色字体）","uri":"/windows-cmd-ansi/"},{"categories":["Tips"],"content":"效果展示 原来效果 现在效果 ","date":"2020-01-11","objectID":"/windows-cmd-ansi/:0:3","tags":["CMD","ANSI"],"title":"解决win10的cmd命令行不转义ANSI序列（让cmd输出彩色字体）","uri":"/windows-cmd-ansi/"},{"categories":["Tips"],"content":"参考博客 博客园naiij博主 ","date":"2020-01-11","objectID":"/windows-cmd-ansi/:0:4","tags":["CMD","ANSI"],"title":"解决win10的cmd命令行不转义ANSI序列（让cmd输出彩色字体）","uri":"/windows-cmd-ansi/"},{"categories":["Golang"],"content":"golang web程序部署到宝塔面板中，并常驻后台的方法","date":"2019-12-14","objectID":"/golang-web-baota/","tags":["Golang"],"title":"golang写的web程序如何简单的部署到宝塔面板中","uri":"/golang-web-baota/"},{"categories":["Golang"],"content":" 写好的go web 如何在不配置环境的情况下部署到宝塔呢 ","date":"2019-12-14","objectID":"/golang-web-baota/:0:0","tags":["Golang"],"title":"golang写的web程序如何简单的部署到宝塔面板中","uri":"/golang-web-baota/"},{"categories":["Golang"],"content":"描述 写好了，如何部署在服务器上，毕竟本地没法给别人用，不多BB 发挥golang的交叉编译功能，我服务器是linux，那我们先编译成linux 先去查看一下我们服务器的型号 uname -a，确认是amd64 确认编译类型mark \" 确认编译类型 GOOS：目标平台的操作系统（darwin、freebsd、linux、windows） GOARCH：目标平台的体系架构（386、amd64、arm） 交叉编译不支持 CGO 所以要禁用它 Terminal执行以下四个命令 SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go 打包完之后有一个main程序，没有后缀 编译后文件mark \" 编译后文件 在宝塔面板文件中创建一个文件夹，将这个文件上传上去 我们在终端中进入这个文件目录，然后./main就可以跑起来了 服务器mark \" 服务器 注意：golang的http已经开启了一个端口，那我们需要去开启安全组对应的端口，之后跑起来就可以用ip:port来访问了 如果想通过访问域名来访问到golang的程序，那么我们需要了解nginx的反向代理知识 宝塔面板有傻瓜式设置反向代理 设置完了之后就可以通过域名访问了 宝塔设置代理mark \" 宝塔设置代理 ","date":"2019-12-14","objectID":"/golang-web-baota/:1:0","tags":["Golang"],"title":"golang写的web程序如何简单的部署到宝塔面板中","uri":"/golang-web-baota/"},{"categories":["Golang"],"content":"如何保持程序在linux中后台运行 没有后台运行，当我们关掉终端就会结束掉程序，那有什么意义呢 了解一下linux的screen命令 下载screen yum install screen 【终端操作】 （需要在物理shell中操作） screen -S name 创建 名为name的 screen screen -a 然后 d 暂时离开此screen 后台继续运行 screen -ls 列出所有screen 进程 pid 与名称 screen -r + pid（或者名称）回到screen(attached状态）,如果就一个screen进程，可以省略 pid 【终端中的窗口操作】（挂载某个终端） Ctrl+a c ：创建窗口 Ctrl+a w ：窗口列表 Ctrl+a n ：下一个窗口 Ctrl+a p ：上一个窗口 Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换 Ctrl+a K(大写) ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态） exit ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态） Ctrl+a d ：退出当前终端，返回加载screen前的shell命令状态 如何关闭一个终端？ 如果需要关闭一个终端，可以先进入此终端，然后将所有窗口关闭，当所有窗口都关闭的时候，终端自动关闭，并且出现“[screen is terminating]”。 具体命令如下 // 1. 关闭某个进程 screen kill pid / Screen -S pid -X quit // 2. 关闭全部进程 screen killall // 3. 在进程中关闭 exit / ctrl+c 运行图mark \" 运行图 ","date":"2019-12-14","objectID":"/golang-web-baota/:2:0","tags":["Golang"],"title":"golang写的web程序如何简单的部署到宝塔面板中","uri":"/golang-web-baota/"},{"categories":["Golang"],"content":"收集自Golang中文网并已经传到了Github。","date":"2019-11-18","objectID":"/golang-interview/","tags":["Golang"],"title":"Golang面试题及解析","uri":"/golang-interview/"},{"categories":["Golang"],"content":" 收集来自Golang中文网公众号每天一篇面试题，收集是为了自己可以巩固复习，不必要每次去找，现已挪到github记录 ","date":"2019-11-18","objectID":"/golang-interview/:0:0","tags":["Golang"],"title":"Golang面试题及解析","uri":"/golang-interview/"},{"categories":["Golang"],"content":"github同步地址： https://github.com/yqchilde/Golang-Interview ","date":"2019-11-18","objectID":"/golang-interview/:1:0","tags":["Golang"],"title":"Golang面试题及解析","uri":"/golang-interview/"},{"categories":["MySQL"],"content":"记录一下MySQL在做插入操作时怎么去指定条件","date":"2019-10-26","objectID":"/mysql-insert-how-where/","tags":["MySQL"],"title":"MySQL中insert数据时怎么用where条件","uri":"/mysql-insert-how-where/"},{"categories":["MySQL"],"content":"这是一个坑 在之前写PHP中想去添加一条数据，并且想查询是否在插入之前有这条数据，我会沙雕的做法（emmm,之前我不知道我这么沙雕了）就是写两个sql语句，分别让他们去单独执行:sleepy: 简单点得一句sql语句，如下： INSERT INTO 表名(字段一,字段二) SELECT '字段值','字段值' FROM DUAL WHERE NOT EXISTS(SELECT 数据 FROM 表名 WHERE 条件) 例如 ： insert into tb(name,age) select 'fox',20 from DUAL where not EXISTS(select name from tb where name='fox') DUAL 是虚拟表为了满足 select …from …..格式 ","date":"2019-10-26","objectID":"/mysql-insert-how-where/:0:1","tags":["MySQL"],"title":"MySQL中insert数据时怎么用where条件","uri":"/mysql-insert-how-where/"},{"categories":["MySQL"],"content":"2019/10/2补充 现在在用Golang写web业务，补充一下之前的例子吧 // UserAdd 添加用户 func UserAdd(mod *User) error { tx, _ := Db.Begin() result, err := tx.Exec(\"insert into user(num,name,pass,phone,email,ctime) SELECT ?,?,?,?,?,? from DUAL where ? NOT IN ( SELECT `num` FROM USER )\", mod.Num, mod.Name, mod.Pass, mod.Phone, mod.Email, mod.Ctime, mod.Num) if err != nil { tx.Rollback() return err } rows, _ := result.RowsAffected() if rows \u003c 1 { tx.Rollback() return errors.New(\"rows affected \u003c 1\") } tx.Commit() return nil } 通过这个例子可以看出来我们只需要判断num字段时候已经存在，存在情况下就会返回Affected rows: 0，So判断RowsAffected就行，不存在就直接插入了 ","date":"2019-10-26","objectID":"/mysql-insert-how-where/:0:2","tags":["MySQL"],"title":"MySQL中insert数据时怎么用where条件","uri":"/mysql-insert-how-where/"},{"categories":["MySQL"],"content":"错误的原因是 5.7版本下的mysql数据库下已经没有password这个字段了，password字段改成了authentication_string","date":"2019-10-06","objectID":"/mysql5.7-update-password/","tags":["MySQL"],"title":"MySQL5.7修改root密码","uri":"/mysql5.7-update-password/"},{"categories":["MySQL"],"content":"在网上看到这行命令并使用 select host,user,password from mysql.user; 然后报错了 ERROR 1054 (42S22): Unknown column 'password' in 'field list'  错误的原因是 5.7版本下的mysql数据库下已经没有password这个字段了，password字段改成了authentication_string 正确操作如下： mysql\u003e use mysql Database changed mysql\u003e select User from user; +-----------+ | User | +-----------+ | mysql.sys | | root | +-----------+ 2 rows in set (0.00 sec) mysql\u003e update mysql.user set authentication_string=password('root') where user='root'; Query OK, 0 rows affected, 1 warning (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 1 mysql\u003e flush privileges; Query OK, 0 rows affected (0.00 sec) mysql\u003e quit Bye ","date":"2019-10-06","objectID":"/mysql5.7-update-password/:1:0","tags":["MySQL"],"title":"MySQL5.7修改root密码","uri":"/mysql5.7-update-password/"},{"categories":["Tips"],"content":"'介于每天手动收能量、偷能量很浪费我们的时间，所以我想写这样一个脚本，开始我最先想到的是按键精灵，但是这个软件得需要手机root,所以在酷安看到了这么一款软件-\u003e一触即发 。是利用了无障碍模式，所以不用root,但是需要安卓版本大于7.0好像。类似的软件又Auto.js，但是现在貌似作者由于一些原因已经下架了，我无法下载，所以就用这个，实现最重要。'","date":"2019-09-20","objectID":"/mayisenlin-script/","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["Tips"],"content":" 介于每天手动收能量、偷能量很浪费我们的时间，所以我想写这样一个脚本，开始我最先想到的是按键精灵，但是这个软件得需要手机root,所以在酷安看到了这么一款软件-\u003e一触即发 。是利用了无障碍模式，所以不用root,但是需要安卓版本大于7.0好像。类似的软件又Auto.js，但是现在貌似作者由于一些原因已经下架了，我无法下载，所以就用这个，实现最重要。 ","date":"2019-09-20","objectID":"/mayisenlin-script/:0:0","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["Tips"],"content":"思路 打开支付宝APP 寻找蚂蚁森林入口 进入蚂蚁森林，识别能量球颜色，循环之后结束 滑到底部打开查看所有好友 每一个可以偷取能量的好友右侧都有一个小手的图标,记得这一块要遍历循环，没有就下滑，就有收取，直到滑动到最底部结束。 ","date":"2019-09-20","objectID":"/mayisenlin-script/:0:1","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["Tips"],"content":"视频看一下吧 ","date":"2019-09-20","objectID":"/mayisenlin-script/:0:2","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["Tips"],"content":"代码 目前版本的一触即发还不能导出代码，可以扫码体验 ","date":"2019-09-20","objectID":"/mayisenlin-script/:0:3","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["Tips"],"content":"体验地址 ","date":"2019-09-20","objectID":"/mayisenlin-script/:0:4","tags":["Javascript"],"title":"利用脚本软件“一触即发”写一个自动收取，偷取支付宝能量脚本","uri":"/mayisenlin-script/"},{"categories":["PHP"],"content":"在写发送邮件时发现移植过来的PHPMailer是旧版的（是没有namespace）的，在后面的版本官方才更新过来，于是我在github下载到最新的版本准备写一个发送邮件","date":"2019-09-19","objectID":"/use-phpmailer/","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":" 在写发送邮件时发现移植过来的PHPMailer是旧版的（是没有namespace）的，在后面的版本官方才更新过来，于是我在github下载到最新的版本准备写一个发送邮件 ","date":"2019-09-19","objectID":"/use-phpmailer/:0:0","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"第一步 当然是下载 PHPMailer 地址：https://github.com/PHPMailer/PHPMailer ","date":"2019-09-19","objectID":"/use-phpmailer/:0:1","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"第二步 将文件引入项目中，只保留 src 目录，其余的不用留 ","date":"2019-09-19","objectID":"/use-phpmailer/:0:2","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"第三步 新建一个文件，文件名为 sendMail.php ，写如下代码进行配置 \u003c?php namespace dncTool; use PHPMailerPHPMailerPHPMailer; use PHPMailerPHPMailerException; //引入项目 $dir = dirname(__FILE__) . '/PHPMailer'; require ($dir . '/src/Exception.php'); require ($dir . '/src/PHPMailer.php'); require ($dir . '/src/SMTP.php'); class sendMail { public static $Host = 'smtp.163.com'; //smtp服务器 private static $From = '这里写邮件地址'; //发送者的邮件地址 private static $FromName = '签到助手'; //发送邮件的用户昵称 private static $Username = '这里写邮件地址'; //登录到邮箱的用户名 private static $Password = '授权码'; //第三方登录的授权码，在邮箱里面设置 /** * 发送 * @param $sendMail * @param $mailTitle * @param $content * @return bool */ public function send($sendMail,$mailTitle,$content) { //实例化PHPMail类 $mail = new PHPMailer(true); try { //Server settings $mail-\u003eSMTPDebug = 0; // 关闭Dubug模式 $mail-\u003eisSMTP(); // 使用SMTP发送邮件 $mail-\u003eHost = self::$Host; //SMTP邮件服务器地址（腾讯企业邮为例） $mail-\u003eSMTPAuth = true; //发信认证 $mail-\u003eUsername = self::$Username; // SMTP 发件人邮箱 $mail-\u003ePassword = self::$Password; // SMTP 发件人邮箱密码 $mail-\u003eSMTPSecure = 'ssl'; //ssl协议 $mail-\u003ePort = 465; //ssl端口号 //发件人 $mail-\u003esetFrom(self::$From, self::$FromName); //发件人邮箱（同 $mail-\u003eUsername项设置）、发件人名称 //收件人。多收件人可设置多个addAddress $mail-\u003eaddAddress($sendMail, ''); //收件人邮箱地址，收件人姓名（选填） //$mail-\u003eaddAddress('ellen@example.com'); // 收件人邮箱地址 //邮件内容 $mail-\u003eisHTML(true); //发送html格式邮件 $mail-\u003eSubject = $mailTitle; //邮件标题 $mail-\u003eBody = $content; //邮件内容 $mail-\u003eAltBody = '邮件摘要'; //目测没什么用，可去掉 //判断是否发送成功 if ($mail-\u003esend()) { return true; } else { return false; } } catch (Exception $e) { return $mail-\u003eErrorInfo; } } } ","date":"2019-09-19","objectID":"/use-phpmailer/:0:3","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"第四步 在另一个地方实例化这个类就行，然后就可以进行参数传递，代码如下： $mailSend = new dncToolsendMail(); //设置要发送的邮箱 $sendMail=$email; //邮件标题 $mailTitle = \"您收到签到助手的一条邮件\"; //$content为邮件内容 $newPwd = $this-\u003emakeCardPassword(); $content=\"\u003cdiv\u003e\u003cb\u003e您的新密码为：\" . $newPwd . \",请尽快登陆并修改密码\u003c/b\u003e\u003c/div\u003e\"; //执行发信 $sendRes = $mailSend-\u003esend($sendMail,$mailTitle,$content); if ($sendRes == false) { exit(jsonCode('error','服务错误，请重新尝试')); } else { exit(jsonCode('ok','已将重置后的密码发送到您的邮箱中！')); } ","date":"2019-09-19","objectID":"/use-phpmailer/:0:4","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"然后直接调用第四步方法就可以成功发信 收到邮件mark \" 收到邮件 发送邮件mark \" 发送邮件 ","date":"2019-09-19","objectID":"/use-phpmailer/:0:5","tags":["PHP"],"title":"PHPMailer6.0.7如何在类中被调用","uri":"/use-phpmailer/"},{"categories":["PHP"],"content":"php多维数组降维记载","date":"2019-08-20","objectID":"/php-array/","tags":["PHP"],"title":"php多维数组降维记载","uri":"/php-array/"},{"categories":["PHP"],"content":"多维数组降一维数组 /** * 多维数组变成一维数组 * @param $array * @param array $return * @return array */ public function arr_foreach($array,$return=[]) { array_walk_recursive($array,function($value) use (\u0026$return) { $return[]=$value; }); return $return; } 调用方式 $this-\u003earr_foreach(多维数组) ","date":"2019-08-20","objectID":"/php-array/:0:1","tags":["PHP"],"title":"php多维数组降维记载","uri":"/php-array/"},{"categories":["PHP"],"content":"三维数组降二维数组 /** * 三维数组转二维数组 * @param $array * @return array */ public function array3_to_array2($array) { $array = array_filter($array); $array = array_values($array); foreach ($array as $k =\u003e$v) { $count = count($v); if ($count \u003e 1) { for ($i = 0;$i \u003c $count;$i++) { $resArr[] = $v[$i]; } } else { $resArr[] = $v[0]; } } return $resArr; } 调用方式 $this-\u003earray3_to_array2(三维数组) ","date":"2019-08-20","objectID":"/php-array/:0:2","tags":["PHP"],"title":"php多维数组降维记载","uri":"/php-array/"},{"categories":["PHP"],"content":"PHP如何在foreach中合并数组呢？","date":"2019-08-19","objectID":"/php-foreach-merge/","tags":["PHP"],"title":"php在foreach里面合并数组","uri":"/php-foreach-merge/"},{"categories":["PHP"],"content":"用到的函数 array_merge() call_user_func_array 如果直接两个数组合并，那十分简单，如下 $a1=array(\"red\",\"green\"); $a2=array(\"blue\",\"yellow\"); print_r(array_merge($a1,$a2)); // 结果如下 // Array ( [0] =\u003e red [1] =\u003e green [2] =\u003e blue [3] =\u003e yellow ) ","date":"2019-08-19","objectID":"/php-foreach-merge/:0:1","tags":["PHP"],"title":"php在foreach里面合并数组","uri":"/php-foreach-merge/"},{"categories":["PHP"],"content":"如何在foreach里面合并相同的 “内容” 为数组 foreach ($array as $k =\u003e $v) { $array[] = $db-\u003ewhere('classid = ?', array($v['cid']))-\u003efetchAll(); } $result = call_user_func_array('array_merge', $array); print_r($result); // 这样就是有几条就连接起来了 ","date":"2019-08-19","objectID":"/php-foreach-merge/:0:2","tags":["PHP"],"title":"php在foreach里面合并数组","uri":"/php-foreach-merge/"},{"categories":["PHP"],"content":"众所周知php的 `time` 函数生成的是10位的时间戳，为了方便与js进行处理，js是13位时间戳，记录下转换方法","date":"2019-08-09","objectID":"/php-js-timestamp/","tags":["PHP","Javascript"],"title":"php与js的时间戳相关问题","uri":"/php-js-timestamp/"},{"categories":["PHP"],"content":"php生成13位时间戳 众所周知php的 time 函数生成的是10位的时间戳，为了方便与js进行处理，js是13位时间戳，转化函数如下： /** * 生成13位时间戳 * @return float */ public function getMillisecond() { list($t1, $t2) = explode(' ', microtime()); return (float)sprintf('%.0f',(floatval($t1)+floatval($t2))*1000); } ","date":"2019-08-09","objectID":"/php-js-timestamp/:0:1","tags":["PHP","Javascript"],"title":"php与js的时间戳相关问题","uri":"/php-js-timestamp/"},{"categories":["PHP"],"content":"js处理10位/13位时间戳转换成时间 timestampToTime: function(timestamp, type=1) { var date = new Date(timestamp * 1000);//时间戳为10位需*1000，时间戳为13位的话不需乘1000 let Y = date.getFullYear() + '.'; let M = (date.getMonth()+1 \u003c 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '.'; let D = date.getDate() + ' '; let h = date.getHours() + ':'; let m = date.getMinutes() let s = date.getSeconds(); if (type == 1) { //全格式 return Y+M+D+h+m+s; } else if (type == 2) { //年月日 return Y+M+D; } else if (type == 3) { //时分秒 return h+m+s; } } ","date":"2019-08-09","objectID":"/php-js-timestamp/:0:2","tags":["PHP","Javascript"],"title":"php与js的时间戳相关问题","uri":"/php-js-timestamp/"},{"categories":["Uni-App"],"content":"uniapp的Form的picker要这样用才对","date":"2019-08-01","objectID":"/uniapp-form-picker/","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["Uni-App"],"content":"思路 哪有思路，菜鸡是没有思路的，本文参考小程序club的一篇文章写的关于uniapp的写法。 参考地址 ： http://www.wxappclub.com/topic/687 ","date":"2019-08-01","objectID":"/uniapp-form-picker/:0:1","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["Uni-App"],"content":"效果图 效果图mark \" 效果图 ","date":"2019-08-01","objectID":"/uniapp-form-picker/:0:2","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["Uni-App"],"content":"可能感觉很好写 其实这里有一个蛋疼的地方，借用原作者的一句话，picker通过form提交的时候，肯定提交的是自己的value，那么就相当于永远提交的是0、1、2、3、4、5…… 这样的话问题就来了，咱们要这些个0123有个毛用？所以你会发现官方文档给的，只能返回索引值。 参数mark \" 参数 ","date":"2019-08-01","objectID":"/uniapp-form-picker/:0:3","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["Uni-App"],"content":"uniapp写法 template部分 \u003cpicker mode=\"selector\" name=\"selector\" @change=\"bindSelectTime\" :value=\"timeIndex\" :range=\"picker_name\"\u003e \u003cview v-if=\"timeShow\"\u003e \u003cview class=\"uni-input\"\u003e{{selectTime[timeIndex].name}}\u003c/view\u003e \u003c/view\u003e \u003cview v-else=\"\"\u003e \u003ctext class=\"lateTime-right\"\u003e请选择时间\u003c/text\u003e \u003ctext class=\"iconfont iconarrow-right-copy-copy\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/picker\u003e script部分 \u003cscript\u003e var that; export default { data() { return { selectTime: [ //时间数据 { \"id\" : \"1min\" , \"name\":\"1分钟\"}, { \"id\" : \"2min\" , \"name\":\"2分钟\"}, { \"id\" : \"3min\" , \"name\":\"3分钟\"}, { \"id\" : \"4min\" , \"name\":\"4分钟\"}, { \"id\" : \"5min\" , \"name\":\"5分钟\"} ], timeIndex: 0, //选择的picker索引 picker_name:[],//picker中range属性值 picker_id:[],//存储id数组 result:'',//form提交最终结果 } }, onLoad() { that = this; // 将selectTime遍历赋值 this.selectTime.forEach(function(e){ that.picker_name.push(e.name); //注意一定要用that,因为this对象此时已经没有传不进来了 that.picker_id.push(e.id); }) }, methods: { bindSelectTime: function(e) { // 绑定选择时间 that.timeShow = true; that.timeIndex = e.detail.value; }, // 表单提交代码 formSubmit: function (e) { // 表单提交 var result = this.picker_id[e.detail.value.selector]; this.result = result; console.log(result); } } } \u003c/script\u003e ","date":"2019-08-01","objectID":"/uniapp-form-picker/:0:4","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["Uni-App"],"content":"还有坑啊 就是在 onLoad 里面的 this.selectTime.forEach 里面必须用that，在之前将this对象赋值给that,因为此时this对象在这个函数里面已经丢失了，可以打印this,会发现是undefined。 或者可以用ES6的箭头函数就可以避免这个问题，如下： this.selectTime.forEach( e =\u003e { this.picker_name.push(e.name); this.picker_id.push(e.id); }) ","date":"2019-08-01","objectID":"/uniapp-form-picker/:0:5","tags":["Uni-App"],"title":"uniapp的Form提交之蛋疼的picker","uri":"/uniapp-form-picker/"},{"categories":["PHP"],"content":"PHP利用foreach给指定数组根据键去添加内容","date":"2019-08-01","objectID":"/php-foreach-push/","tags":["PHP"],"title":"php利用foreach给数组指定键值添加内容","uri":"/php-foreach-push/"},{"categories":["PHP"],"content":"栗子如下 $jsonArr = array(); foreach ($res as $value) { array_push($jsonArr, array('classId' =\u003e $value['classid'], 'className' =\u003e $value['classname'])); } $jsonArr = json_encode($jsonArr, true); exit(print_r($jsonArr)); ","date":"2019-08-01","objectID":"/php-foreach-push/:0:1","tags":["PHP"],"title":"php利用foreach给数组指定键值添加内容","uri":"/php-foreach-push/"},{"categories":["Tips"],"content":"思路就是先将json转换成数组，然后在循环遍历数组，然后再用splice函数进行删除数组","date":"2019-07-31","objectID":"/js-remove-json-object/","tags":["Javascript"],"title":"Js删除json中的对象","uri":"/js-remove-json-object/"},{"categories":["Tips"],"content":"思路 思路就是先将json转换成数组，然后在循环遍历数组，然后再用splice函数进行删除数组 ","date":"2019-07-31","objectID":"/js-remove-json-object/:0:1","tags":["Javascript"],"title":"Js删除json中的对象","uri":"/js-remove-json-object/"},{"categories":["Tips"],"content":"举个栗子 let delId = 3; let jsonArr = ['{\"userList\": [{\"name\": \"yqchilde\", \"userId\": \"2\", \"joinTime\": \"07月31日\"}, {\"name\": \"test404\", \"userId\": \"3\", \"joinTime\": \"07月30日\"}], \"className\": \"计算机科学一班\"}'] jsonArr = JSON.parse(jsonArr); for (let i = 0; i \u003c jsonArr.userList.length; i++) { if (delId == jsonArr.userList[i].userId) { jsonArr.userList.splice(i, 1); } }; jsonArr = JSON.stringify(jsonArr); console.log(jsonArr) //结果如下 // {\"userList\":[{\"name\":\"yqchilde\",\"userId\":\"2\",\"joinTime\":\"07月31日\"}],\"className\":\"计算机科学一班\"} ","date":"2019-07-31","objectID":"/js-remove-json-object/:0:2","tags":["Javascript"],"title":"Js删除json中的对象","uri":"/js-remove-json-object/"},{"categories":["Android"],"content":"本来是配置好的环境，但是一直没发现在控制台，只有java可以用，javac却不能用","date":"2019-07-24","objectID":"/jdk1.8-config/","tags":["Java"],"title":"JDK1.8的环境变量配置","uri":"/jdk1.8-config/"},{"categories":["Android"],"content":" 本来是配置好的环境，但是一直没发现在控制台，只有java可以用，javac却不能用 ","date":"2019-07-24","objectID":"/jdk1.8-config/:0:0","tags":["Java"],"title":"JDK1.8的环境变量配置","uri":"/jdk1.8-config/"},{"categories":["Android"],"content":"1.5以后不再需要JAVA_HOME和CLASSPATH 直接在系统环境变量新增jdk的绝对路径就行，如图 成功如图： ","date":"2019-07-24","objectID":"/jdk1.8-config/:0:1","tags":["Java"],"title":"JDK1.8的环境变量配置","uri":"/jdk1.8-config/"},{"categories":["Android"],"content":"1.5以前仍然要配置JAVA_HOME和CLASSPATH JAVA_HOME: 你自己的jdk的路径 CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 注意前面有一个.千万不要忘了。 （注意 如果是1.5以后的JDK版本不需要配置CLASSPATH） ","date":"2019-07-24","objectID":"/jdk1.8-config/:0:2","tags":["Java"],"title":"JDK1.8的环境变量配置","uri":"/jdk1.8-config/"},{"categories":["Uni-App"],"content":"介绍了如何用Uni-App生成邀请二维码并画出来","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"先看效果图 效果图mark \" 效果图 ","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/:0:1","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"引入插件 插件源地址： https://dwz.cn/YbQ9718O import _app from '@/commons/QS-SharePoster/app.js'; import getSharePoster from '@/commons/QS-SharePoster/QS-SharePoster.js'; ","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/:0:2","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"配置背景图片 在 插件中app.js 里面写 getPosterUrl 方法 getPosterUrl(objs) { // 后端获取背景图的url路径方法 let { backgroundImage, type } = objs; return new Promise((rs, rj) =\u003e {//resolve 和 reject let image; if (backgroundImage) image = backgroundImage; else switch (type) { //根据type获取背景图, 一般要改成request获取 case 1: image = ''; break; default: image = 'https://ae01.alicdn.com/kf/HTB1iTw3a8r0gK0jSZFn762RRXXaM.png'; break; } if(image) rs(image); // resolve图片的路径 else rj('背景图片路径不存在'); }) }, 此处会在前台调用，然后返回image给QS整合，地址可以写给后端返回Api接口用request请求获取，我开始也是这样，后来改了，因为在目前功能够用了 ","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/:0:3","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"前台页面 先调起js方法，template代码如下： \u003cview class=\"classBtn\"\u003e \u003ctext class=\"cuIcon-forwardfill\"\u003e\u003c/text\u003e \u003ctext @tap=\"shareFc(index)\"\u003e邀请\u003c/text\u003e \u003c/view\u003e @tap点击事件，我给了一个参数，是为了方便我记录点击的是列表中的哪一个 要展示的图片放在view里面 \u003c!-- 邀请二维码 --\u003e \u003cview class=\"flex_row_c_c modalView\" :class=\"qrShow?'show':''\" @tap=\"hideQr()\"\u003e \u003cview class=\"flex_column\"\u003e \u003cview class=\"backgroundColor-white padding1vh border_radius_10px\"\u003e \u003cimage :src=\"poster.finalPath\" mode=\"widthFix\" class=\"posterImage\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"flex_row marginTop2vh\"\u003e \u003cbutton type=\"primary\" size=\"mini\" @tap.prevent.stop=\"saveImage()\"\u003e保存图片\u003c/button\u003e \u003cbutton type=\"primary\" size=\"mini\" @tap.prevent.stop=\"share()\"\u003e分享图片\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"hideCanvasView\"\u003e \u003ccanvas class=\"hideCanvas\" canvas-id=\"ShareCanvasId\" :style=\"{width: (poster.width||0) + 'px', height: (poster.height||0) + 'px'}\"\u003e\u003c/canvas\u003e \u003c/view\u003e 生成图片展示modal的css样式 /* 邀请二维码 */ .hideCanvasView { position: relative; } .hideCanvas { position: fixed; top: -99999upx; left: -99999upx; z-index: -99999; } .flex_row_c_c { display: flex; flex-direction: row; justify-content: center; align-items: center; } .modalView { width: 100%; height: 100%; position: fixed; top: 0; left: 0; right: 0; bottom: 0; opacity: 0; outline: 0; transform: scale(3); perspective: 2500upx; background: rgba(0, 0, 0, 0.6); transition: all .3s ease-in-out; pointer-events: none; backface-visibility: hidden; z-index: 999; } .modalView.show { opacity: 1; transform: scale(1); pointer-events: auto; } .flex_column { display: flex; flex-direction: column; } .backgroundColor-white { background-color: white; } .border_radius_10px { border-radius: 10px; } .padding1vh { padding: 1vh; } .posterImage { width: 60vw; } .flex_row { display: flex; flex-direction: row; } .marginTop2vh { margin-top: 2vh; } 在 script 先设置data值 data () { return { poster: {}, qrShow: false, canvasId: 'ShareCanvasId', } } 此处的canvasId值固定，用一个canvasId来在画板上绘画 利用 async + await 写同步请求，因为uni.request是封装的异步请求，此处需要同时渲染页面 async shareFc(index) { //分享邀请二维码，参数index是列表点击的索引 if (uni.getStorageSync('tmpIndex') === index) { //判断临时索引是否是点击的索引 this.qrShow = true; } else { try{ uni.setStorageSync('tmpIndex', index); //将点击的索引绑定给本地sync，作为临时索引 let d = await getSharePoster({ //传入两个await参数，一个是类型，一个是canvasID // type: [this.classList[index].userid,this.classList[index].classid], type: 'testShareType', posterCanvasId: this.canvasId, qrCodeArray: (bgObj, type) =\u003e { return [{ text: '二维码内容暂时不写', //后期可以传入相关的二维码参数，以便于扫码时获取 // image: 'https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1559644434957\u0026di=0db394a4ae41b6cff704fa3d4cbd997b\u0026imgtype=0\u0026src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201806%2F30%2F20180630233629_GueV4.thumb.700_0.jpeg', size: 580, //二维码大小 dx: (bgObj.width-580)/2, //x坐标 dy: bgObj.height-1200 //y坐标 }] }, imagesArray: (bgObj, type) =\u003e { //接收的第一个参数为背景图片的信息, 第二个参数是自定义标识（感觉这里用不到）, 图片为示例图片 return [{ url: 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1314428097,3858988978\u0026fm=26\u0026gp=0.jpg', dx: 100, dy: bgObj.height - 300, circleSet: { // 圆形图片 circle: true }, infoCallBack(imageInfo) { let scale = 200/imageInfo.height; return { dWidth: imageInfo.width*scale, dHeight: 200 } } }] }, setCanvasWH: (bgObj, type) =\u003e { // 为动态设置画布宽高的方法， this.poster = bgObj; }, setDraw: (obj) =\u003e { let { Context, bgObj, type } = obj; Context.setFillStyle('black'); Context.setGlobalAlpha(0.3); Context.fillRect(0, bgObj.height - 400, bgObj.width, 400); Context.setGlobalAlpha(1); Context.setFillStyle('white'); Context.setFontSize(100); //输出姓名 let text = uni.getStorageSync('realName'); Context.fillText(text, bgObj.width - text.length * 50 - 160, bgObj.height - 175); //输出班级 Context.setFillStyle('orange'); Context.setFontSize(110); let textTitle = this.classList[index].classname; Context.fillText(textTitle, (bgObj.width - textTitle.length * 110)/2, bgObj.height - 430); } }); console.log('海报生成成功， 临时路径: ' + d.poster.tempFilePath) this.poster.finalPath = d.poster.tempFilePath; console.log(this.poster.finalPath); this.qrShow = tr","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/:0:4","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"扩展知识 ES6的解构赋值 let {msg, data, status} = jsonData; 想调用 `msg` 就是 jsonData.msg; 这就是ES6的新语法糖 var a, b, rest; [a, b] = [10, 20]; console.log(a); // 10 console.log(b); // 20 //直接交换位置 [a, b, ...rest] = [10, 20, 30, 40, 50]; console.log(a); // 10 console.log(b); // 20 console.log(rest); // [30, 40, 50] // ...将剩余数组赋值给一个变量 ({ a, b } = { a: 10, b: 20 }); console.log(a); // 10 console.log(b); // 20 // Stage 4（已完成）提案中的特性 ({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}); console.log(a); // 10 console.log(b); // 20 console.log(rest); // {c: 30, d: 40} 解析从函数中返回的数组 function f() { return [1, 2]; } var a, b; [a, b] = f(); console.log(a); // 1 console.log(b); // 2 也可以忽略掉返回值 function f() { return [1, 2, 3]; } var [a, , b] = f(); //也可以全部忽略 [,,] console.log(a); // 1 console.log(b); // 3 举个例子，比如正则表达式验证 正则mark \" 正则 数组中有6个，我们只想要第一个怎么办？ 选择合适的mark \" 选择合适的 只需要省略掉其他的参数就行 解构对象 var o = {p: 42, q: true}; var {p, q} = o; console.log(p); // 42 console.log(q); // true 无需申明变量即可赋值 ({a, b} = {a: 1, b: 2}); console.log(a); // 1 console.log(b); // 2 给新的变量换名 var o = {p: 42, q: true}; var {p: foo, q: bar} = o; console.log(foo); // 42 console.log(bar); // true ","date":"2019-07-22","objectID":"/uniapp-generate-invitation-qrcode/:0:5","tags":["Uni-App"],"title":"Uni-App生成邀请二维码","uri":"/uniapp-generate-invitation-qrcode/"},{"categories":["Uni-App"],"content":"我搞了3天用php生成验证码，然后session返回验证码的值，这样子直接请求是可以的，但是在小程序里面是只能获取到 `PHPSESSID` ，所以要带着图片的sessionid才能访问到正确的验证码值，奈何在uniapp里面，uni.request请求才能拿到sessionid，但是image标签要想显示这个session的对应的图片，需要动态绑定数据加载，这样就导致了加载的图片请求了一次session，request又请求了一次，我技术不高写不出来了，这才想到了今天要实现的这种方法","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":" 我搞了3天用php生成验证码，然后session返回验证码的值，这样子直接请求是可以的，但是在小程序里面是只能获取到 PHPSESSID ，所以要带着图片的sessionid才能访问到正确的验证码值，奈何在uniapp里面，uni.request请求才能拿到sessionid，但是image标签要想显示这个session的对应的图片，需要动态绑定数据加载，这样就导致了加载的图片请求了一次session，request又请求了一次，我技术不高写不出来了，这才想到了今天要实现的这种方法 没有什么技术，代码如下↓ ","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/:0:0","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":"template代码如下 \u003cmodal-view title=\"请输入验证码\" :no-cancel='true' confirm-text='确定' :hidden.sync='modalHidden'\u003e \u003cview slot='text' class=\"verifyCode\"\u003e \u003cimage id=\"verifyCode\" :src=\"verifySrc\" mode=\"aspectFit\" @click=\"getRandomCode\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/modal-view\u003e ","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/:1:0","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":"script代码如下 getRandomCode: function() { // 生成验证码 let code = new Array(); let codeLength = 6;//验证码的长度 let selectChar = new Array(2,3,4,5,6,7,8,9,'a','b','c','d','e','f','g','h','j','k','l','m','n','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z'); for(let i=0;i\u003ccodeLength;i++) { let charIndex = Math.floor(Math.random()*56); // 56是selectChar数组的长度 code +=selectChar[charIndex]; } if(code.length != codeLength) { this.getRandomCode(); } uni.request({ url: this.verifySrc = that.apiServer + 'user\u0026m=verifyView', method: 'POST', responseType:'arrayBuffer', //设置responseType是为了转化图片为base64 header : {'content-type':'application/x-www-form-urlencoded'}, data: { code }, success: res =\u003e { let verifyImg = 'data:image/jpeg;base64,' + uni.arrayBufferToBase64(res.data); // 设置图片动态绑定的src路径 this.verifySrc = verifyImg; }, fail: (res) =\u003e { console.log(\"请检查网络\"); } }); } **注意：**不转化为base64的话图片是 未转base64mark \" 未转base64 ","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/:2:0","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":"php端代码 控制器代码 \u003c?php /** * User: yqchilde * Date: 2019/7/1 * Time: 22:06 */ namespace dnC; class user { public function verifyView() { if (isset($_POST['code'])) { $imgModel = new \\dncTool\\verifyImage(); $imgModel-\u003ebuild($_POST['code']); } else { exit(jsonCode('error', '获取二维码失败')); } } } verifyImage代码 \u003c?php /** * 验证码类 * User: yqchilde * Date: 2019/7/6 * Time: 21:55 */ namespace dncTool; class verifyImage { public function __construct() { $this-\u003efont = 'simhei.ttf'; } static function create(){ static $instance ; if (!$instance){ $instance = new verifyImage(); } return $instance; } private $code;//验证码 private $codeLen = 6;//验证码长度 private $width = 130;//宽度 private $height = 50;//高度 private $img;//图形资源句柄 private $font;//指定的字体 private $fontsize = 20;//指定字体大小 private $fontcolor;//指定字体颜色 //生成随机码 private function createCode($code) { $this-\u003ecode .= $code; } //生成背景 private function createBg() { $this-\u003eimg = imagecreatetruecolor($this-\u003ewidth, $this-\u003eheight); $color = imagecolorallocate($this-\u003eimg, mt_rand(157,255), mt_rand(157,255), mt_rand(157,255)); imagefilledrectangle($this-\u003eimg,0,$this-\u003eheight,$this-\u003ewidth,0,$color); } //生成文字 private function createFont() { $_x = $this-\u003ewidth / $this-\u003ecodeLen; //$this-\u003ecode = array(\"天\", \"地\", \"人\", \"和\", \"梦\",);//随机因子 for ($i=0;$i\u003c$this-\u003ecodeLen;$i++) { $this-\u003efontcolor = imagecolorallocate($this-\u003eimg,mt_rand(0,156),mt_rand(0,156),mt_rand(0,156)); imagettftext($this-\u003eimg,$this-\u003efontsize,mt_rand(-30,30),$_x*$i+mt_rand(1,5),$this-\u003eheight / 1.4,$this-\u003efontcolor,$this-\u003efont,$this-\u003ecode[$i]); } } //生成线条、雪花 private function createLine() { //线条 for ($i=0;$i\u003c6;$i++) { $color = imagecolorallocate($this-\u003eimg,mt_rand(0,156),mt_rand(0,156),mt_rand(0,156)); imageline($this-\u003eimg,mt_rand(0,$this-\u003ewidth),mt_rand(0,$this-\u003eheight),mt_rand(0,$this-\u003ewidth),mt_rand(0,$this-\u003eheight),$color); } //雪花 for ($i=0;$i\u003c100;$i++) { $color = imagecolorallocate($this-\u003eimg,mt_rand(200,255),mt_rand(200,255),mt_rand(200,255)); imagestring($this-\u003eimg,mt_rand(1,5),mt_rand(0,$this-\u003ewidth),mt_rand(0,$this-\u003eheight),'*',$color); } } //输出 private function outPut() { header('Content-type:image/png'); imagepng($this-\u003eimg); imagedestroy($this-\u003eimg); } //对外生成 public function vCodePicture($code) { $this-\u003ecreateBg(); $this-\u003ecreateCode($code); $this-\u003ecreateLine(); $this-\u003ecreateFont(); $this-\u003eoutPut(); } //获取验证码 public function getCode() { return strtolower($this-\u003ecode); } public function build($code) { $this-\u003evCodePicture($code); } } ","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/:3:0","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":"看一下最后的样子 效果图mark \" 效果图 ","date":"2019-07-11","objectID":"/uniapp-generate-random-verification-code/:3:1","tags":["Uni-App"],"title":"uniapp生成随机验证码\u0026php合成验证码图片","uri":"/uniapp-generate-random-verification-code/"},{"categories":["Uni-App"],"content":"记载一下uniapp携带session的请求","date":"2019-07-11","objectID":"/uniapp-with-session/","tags":["Uni-App"],"title":"Uni-App之携带session请求","uri":"/uniapp-with-session/"},{"categories":["Uni-App"],"content":" 好久没写博客了，是因为（白天都在驾校学车，晚上做项目）哈哈，强势找借口，记载一下uniapp携带session的请求 ","date":"2019-07-11","objectID":"/uniapp-with-session/:0:0","tags":["Uni-App"],"title":"Uni-App之携带session请求","uri":"/uniapp-with-session/"},{"categories":["Uni-App"],"content":"header请求头 在uniapp里面uni.request是类似于ajax的异步请求，请求适合可以携带header头，那我们给header头加一个cookie信息即可，如下 let headers = {}; headers['content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8'; let PHPSESSID = uni.getStorageSync('PHPSESSID'); if (PHPSESSID) { headers['cookie'] = 'PHPSESSID=' + PHPSESSID; } 将session放在header这个对象里面，同理当然也可以写其他需要的cookie信息 ","date":"2019-07-11","objectID":"/uniapp-with-session/:0:1","tags":["Uni-App"],"title":"Uni-App之携带session请求","uri":"/uniapp-with-session/"},{"categories":["Uni-App"],"content":"官方文档上面只有说支持 `touchmove` 但是却没给一个demo，实现过程在这里了。","date":"2019-06-15","objectID":"/uniapp-shoushi-huadong/","tags":["Uni-App"],"title":"Uni-App的手势监听滑动","uri":"/uniapp-shoushi-huadong/"},{"categories":["Uni-App"],"content":"踩坑 官方文档上面只有说支持 touchmove 但是却没给一个demo ","date":"2019-06-15","objectID":"/uniapp-shoushi-huadong/:0:1","tags":["Uni-App"],"title":"Uni-App的手势监听滑动","uri":"/uniapp-shoushi-huadong/"},{"categories":["Uni-App"],"content":"效果图 效果图mark \" 效果图 ","date":"2019-06-15","objectID":"/uniapp-shoushi-huadong/:0:2","tags":["Uni-App"],"title":"Uni-App的手势监听滑动","uri":"/uniapp-shoushi-huadong/"},{"categories":["Uni-App"],"content":"代码如下 \u003ctemplate\u003e \u003cview class=\"page\" @touchmove=\"touchRight\" @touchstart=\"touchStart\" @touchend=\"touchEnd\"\u003e \u003cuni-drawer :visible=\"showLeft\" mode=\"left\" @close=\"closeDrawer('left')\"\u003e \u003c!-- @close=\"closeDrawer('left')\" --\u003e \u003cuni-list-item title=\"Item1\" /\u003e \u003cuni-list-item title=\"Item2\" /\u003e \u003cuni-list-item :show-badge=\"true\" title=\"Item3\" badge-text=\"12\" /\u003e \u003c/uni-drawer\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e import uniDrawer from \"@/components/uni-drawer/uni-drawer.vue\" import uniList from '@/components/uni-list/uni-list.vue' import uniListItem from '@/components/uni-list-item/uni-list-item.vue' var that; export default { components: { uniDrawer, uniList, uniListItem }, data() { return { showLeft: false, flag: 0, text: '', lastX: 0, lastY: 0, } }, onLoad() { that = this; }, methods: { showDrawer: function(e) { if (e === 'left') { that.showLeft = true } }, closeDrawer: function(e) { if (e === 'left') { that.showLeft = false } }, touchRight: function(e) { // 向右移动 console.log(\"移动中\"); if (that.flag !== 0) { return; } let currentX = e.touches[0].pageX; let currentY = e.touches[0].pageY; let tx = currentX - that.lastX; let ty = currentY - that.laseY; let text = \"\"; that.mindex = -1; //左右方向滑动 if (Math.abs(tx) \u003e Math.abs(ty)) { if (tx \u003c 0) { text = '向左滑动'; that.flag = 1; // that.closeDrawer('left'); console.log(text); } else if (tx \u003e 0) { text = '向右滑动'; that.flag = 2; that.showDrawer('left'); console.log(text); } } }, // touchTop: function(e) { // 上下移动 // if (that.flag !== 0) { // return; // } // let currentX = e.touches[0].pageX; // let currentY = e.touches[0].pageY;8 // let tx = currentX - that.lastX; // let ty = currentY - that.laseY; // that.mindex = -1; // if (Math.abs(tx) \u003c= Math.abs(ty)) { //上下方向滑动 // if (ty \u003c 0) { //向上滑动 // this.flag = 1; // this.floatButton = 'inline'; // } else if (ty \u003e 0) { // 向下滑动 // this.flag = 2; // this.floatButton = 'none' // } // } // // this.lastX = currentX; // this.lastY = currentY; // }, touchStart: function(e) { //开始移动 console.log(\"开始移动\"); // that.showDrawer('left'); that.lastX = e.touches[0].pageX; that.laseY = e.touches[0].pageY; }, touchEnd: function(e) { // 结束移动 console.log(\"结束移动\"); that.flag = 0; that.text = \"没有滑动\" } } } \u003c/script\u003e ","date":"2019-06-15","objectID":"/uniapp-shoushi-huadong/:0:3","tags":["Uni-App"],"title":"Uni-App的手势监听滑动","uri":"/uniapp-shoushi-huadong/"},{"categories":["MySQL"],"content":"这是我的第二篇MySQL复习笔记","date":"2019-06-03","objectID":"/mysql-note-second/","tags":["MySQL"],"title":"MySQL复习笔记二","uri":"/mysql-note-second/"},{"categories":["MySQL"],"content":"MySQL复习笔记一： http://www.yqqy.top/notes/311 ","date":"2019-06-03","objectID":"/mysql-note-second/:0:0","tags":["MySQL"],"title":"MySQL复习笔记二","uri":"/mysql-note-second/"},{"categories":["MySQL"],"content":"创建存储过程 DELIMITER // CREATE PROCEDURE p_stu1(IN student_name char(10),IN course_name char(20)) BEGIN SELECT Sname, Cname, Grade FROM xs s JOIN xk ON s.sno = xk.sno INNER JOIN kc c ON c.cno = xk.cno WHERE sname = student_name AND cname = course_name; END // DELIMITER; ","date":"2019-06-03","objectID":"/mysql-note-second/:0:1","tags":["MySQL"],"title":"MySQL复习笔记二","uri":"/mysql-note-second/"},{"categories":["MySQL"],"content":"调用存储过程 call p_stu1(\"zhangsan\", \"mysql\"); ","date":"2019-06-03","objectID":"/mysql-note-second/:0:2","tags":["MySQL"],"title":"MySQL复习笔记二","uri":"/mysql-note-second/"},{"categories":["MySQL"],"content":"创建数据库用户 CREATE USER 'yqchilde' @ '%' IDENTFIND BY PASSWORD 'root' ","date":"2019-06-03","objectID":"/mysql-note-second/:0:3","tags":["MySQL"],"title":"MySQL复习笔记二","uri":"/mysql-note-second/"},{"categories":["Python"],"content":"记录一下用Python的Scrapy库爬虫","date":"2019-05-27","objectID":"/first-using-scrapy/","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"实操python的Scrapy库，也就是爬虫很强大的一个库 今天要练习的是一个新闻网，如下 网站mark \" 网站 ","date":"2019-05-27","objectID":"/first-using-scrapy/:0:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"创建项目 首先我们先在控制台创建一个 Scrapy 项目 scrapy startproject 项目名称 创建项目mark \" 创建项目 ","date":"2019-05-27","objectID":"/first-using-scrapy/:1:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"添加爬虫域 我们先用 cd news 进入爬虫文件中，然后再添加爬虫域 scrapy genspider new hxfzzx.com 添加爬虫域mark \" 添加爬虫域 ","date":"2019-05-27","objectID":"/first-using-scrapy/:2:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"目录结构 看下一下scrapy的代码目录结构 目录结构mark \" 目录结构 spiders/: 放置spider代码的目录 new.py: 该项目的python模块 items.py: 项目中的item文件 middlewares.py:爬虫中间件 piplines.py:项目中处理数据行为.如:一般结构化的数据持久化 settings.py:项目的设置文件 ","date":"2019-05-27","objectID":"/first-using-scrapy/:3:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"分析元素 先在 items.py 里面写下爬虫元素 # -*- coding: utf-8 -*- # Define here the models for your scraped items # # See documentation in: # https://doc.scrapy.org/en/latest/topics/items.html import scrapy class NewsItem(scrapy.Item): # define the fields for your item here like: new_title = scrapy.Field() new_time = scrapy.Field() new_href = scrapy.Field() content_img = scrapy.Field() content = scrapy.Field() ","date":"2019-05-27","objectID":"/first-using-scrapy/:4:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"编写脚本 然后在 new.py 里面写项目代码 # -*- coding: utf-8 -*- import scrapy from news.items import NewsItem class NewSpider(scrapy.Spider): name = 'new' allowed_domains = ['hxfzzx.com'] # 爬虫域 start_urls = ['http://www.hxfzzx.com/news/fzfj/'] # 开始爬取的地址 def parse(self, response): li_list = response.xpath(\"//div[@class='zw']//li\") # 分析页面元素 for li in li_list: item = NewsItem() item[\"new_title\"] = li.xpath(\"./a/text()\").extract_first() # 分别取出新闻标题，新闻时间，新闻详情页地址 item[\"new_time\"] = li.xpath(\"./span/text()\").extract_first() item[\"new_href\"] = li.xpath(\"./a/@href\").extract_first() if item[\"new_href\"] is None: # 因为此处会爬虫有None的数据，所以过滤一下 continue # 发起一个请求，去获取详情页 yield scrapy.Request( item[\"new_href\"], callback=self.parse_detail, meta={\"item\": item} ) # 遍历10页的内容 next_url = response.xpath(\"//div[@id='pages']/a[@class='a1'][3]/@href\").get() if next_url != \"/news/fzfj/11.html\": next_url = \"http://www.hxfzzx.com\"+next_url yield scrapy.Request( next_url, callback=self.parse ) # 获取详情页信息 def parse_detail(self, response): item = response.meta[\"item\"] item[\"content\"] = response.xpath(\"//div[@class='zw show']\").extract() # 获取详情页的内容，此处将他的div整个都爬了，方便格式 yield item ","date":"2019-05-27","objectID":"/first-using-scrapy/:5:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"处理数据 最后在 pipelines.py 这个文件里写数据处理代码，并将其提交到mysql数据库中，mysql中创建的字段如下 处理数据mark \" 处理数据 pipelines.py 代码如下： # -*- coding: utf-8 -*- # Define your item pipelines here # # Don't forget to add your pipeline to the ITEM_PIPELINES setting # See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html import pymysql class NewsPipeline(object): def __init__(self): # 连接MySQL数据库 self.connect = pymysql.connect(host='连接ip', user='用户名', password='密码', db='数据库名', port=3306) self.cursor = self.connect.cursor() def process_item(self, item, spider): # 往数据库里面写入数据 sql = \"insert into news(`new_title`, `new_time`, `new_href`, `content`) values (%s, %s, %s, %s)\" self.cursor.execute(sql, (item['new_title'], item['new_time'], item['new_href'], item['content'])) self.connect.commit() return item # 关闭数据库 def close_spider(self, spider): self.cursor.close() self.connect.close() ","date":"2019-05-27","objectID":"/first-using-scrapy/:6:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"注意 注意事项，要在 setting.py 代码中将pipelines的注释打开 注意事项mark \" 注意事项 ","date":"2019-05-27","objectID":"/first-using-scrapy/:7:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"运行 最后我们运行一下代码文件 scrapy crawl new ","date":"2019-05-27","objectID":"/first-using-scrapy/:8:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Python"],"content":"效果 效果如下： 运行效果res.gif \" 运行效果 ","date":"2019-05-27","objectID":"/first-using-scrapy/:9:0","tags":["Python"],"title":"Scrapy第一次爬虫（并将数据传到mysql中）","uri":"/first-using-scrapy/"},{"categories":["Android"],"content":"记载RecyclerView的瀑布流布局","date":"2019-05-24","objectID":"/android-learning-recycleview-third/","tags":["Android"],"title":"Android学习RecyclerView笔记三","uri":"/android-learning-recycleview-third/"},{"categories":["Android"],"content":" Android学习RecyclerView笔记一 ： https://yqqy.top/android-learning-recycleview-first Android学习RecyclerView笔记二 ： https://yqqy.top/android-learning-recycleview-second ","date":"2019-05-24","objectID":"/android-learning-recycleview-third/:0:0","tags":["Android"],"title":"Android学习RecyclerView笔记三","uri":"/android-learning-recycleview-third/"},{"categories":["Android"],"content":"STEP 记载的是RecyclerView的瀑布流布局 瀑布流，在笔记二中与之不同的地方当时还是在 setLayoutManager 身上，那么瀑布流的布局是什么呢？ 瀑布流布局： StaggeredGridLayoutManager()，这个方法中有两个参数，第一个是列数（要展示的为几列），第二个是方向（StaggeredGridLayoutManager.VERTICAL）为纵向 同样我们自定义一个函数 MyDecoration 来实现他的分割线，我们给上下左右都加一定的外边距，如下： MyDecorationmark \" MyDecoration 复制一个笔记二中的 GridAdapter 将其命名为 StaggeredGridAdapter ，稍微改一下代码，如下： StaggeredGridAdaptermark \" StaggeredGridAdapter 我们现在来看看瀑布流的效果吧： 瀑布流效果mark \" 瀑布流效果 ","date":"2019-05-24","objectID":"/android-learning-recycleview-third/:0:1","tags":["Android"],"title":"Android学习RecyclerView笔记三","uri":"/android-learning-recycleview-third/"},{"categories":["Android"],"content":"记载RecycleView的水平滚动布局和网格布局","date":"2019-05-23","objectID":"/android-learning-recycleview-second/","tags":["Android"],"title":"Android学习RecyclerView笔记二","uri":"/android-learning-recycleview-second/"},{"categories":["Android"],"content":" Android学习RecyclerView笔记一 ： https://yqqy.top/android-learning-recycleview-first Android学习RecyclerView笔记三 ： https://yqqy.top/android-learning-recycleview-third ","date":"2019-05-23","objectID":"/android-learning-recycleview-second/:0:0","tags":["Android"],"title":"Android学习RecyclerView笔记二","uri":"/android-learning-recycleview-second/"},{"categories":["Android"],"content":"STEP 这节笔记记录RecycleView的另外两个布局 水平滚动布局 \u0026 网格布局 和笔记一一样，先布局两个按钮，进行跳转操作 演示图1mark \" 演示图1 演示图2mark \" 演示图2 先说滚动布局吧 创建一个新的新的activity，命名为 HorRecyclerViewActivity，刚刚的recycleviewActivity就是跳转到这里，同理待会的网格布局也是一样，命名为 GridRecyclerViewActivity 两者相同，不同的地方会特别写出来 GridRecyclerViewActivitymark \" GridRecyclerViewActivity ctrl + 左键 点进去，进行布局，也就是在 activity_hor_recycler_view.xml 文件中布局，布局如下： activity_hor_recycler_view.xmlmark \" activity_hor_recycler_view.xml 引入RecycleView,是v7包中的，笔记一有记录 回到 HorRecyclerViewActivity 中，首先再学习RecyclerView的一个属性 RecyclerView.serOrientation 设置方向（横向 or 纵向） 设置分割线的方法和笔记一中一直，这里不做记录了，之后也是通过回调adapter中返回的索引，来实现点击弹出提示 HorRecyclerViewActivity代码如下： package com.helloworld.recyclerview; import android.graphics.Rect; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; import android.widget.Toast; import com.helloworld.R; public class HorRecyclerViewActivity extends AppCompatActivity { private RecyclerView mRvHor; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_hor_recycler_view); mRvHor = findViewById(R.id.rv_hor); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(HorRecyclerViewActivity.this); linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // 设置水平方向 mRvHor.setLayoutManager(linearLayoutManager); mRvHor.addItemDecoration(new MyDecoration()); // 设置分割线 mRvHor.setAdapter(new HorAdapter(HorRecyclerViewActivity.this, new HorAdapter.OnItemClickListener() { @Override public void onClick(int pos) { Toast.makeText(HorRecyclerViewActivity.this,\"click:\" + pos,Toast.LENGTH_SHORT).show(); } })); } /** * 自定义MyDecoration类，继承RecyclerView.ItemDecoration */ class MyDecoration extends RecyclerView.ItemDecoration { @Override public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.set(0,0,getResources().getDimensionPixelOffset(R.dimen.dividerHeight),0); // 设置分割线在下面，线宽为1dp } } } 然后我们看adapter,水平滚动的 复制笔记一中的LinearAdapter，将其命名为 HorAdapter 同理 待会的网格布局命名为 GridAdapter Adapter实现的目的看笔记一就行 我们只需要改其中的布局就行，创建一个对应的adapter布局，将其命名为 layout_hor_item.xml，布局如下： layout_hor_item.xmlmark \" layout_hor_item.xml 将其刚刚复制的HorAdapter中的布局修改为这个布局引用 HorAdaptermark \" HorAdapter HorAdapter代码： package com.helloworld.recyclerview; import android.content.Context; import android.support.annotation.NonNull; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import com.helloworld.R; public class GridAdapter extends RecyclerView.Adapter\u003cGridAdapter.LinearViewHolder\u003e { private Context mContext; private OnItemClickListener mListener; public GridAdapter(Context context, OnItemClickListener listener) { this.mContext = context; this.mListener = listener; } @NonNull @Override public GridAdapter.LinearViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) { return new LinearViewHolder(LayoutInflater.from(mContext).inflate(R.layout.layout_gridrv_item,viewGroup,false)); } @Override public void onBindViewHolder(@NonNull GridAdapter.LinearViewHolder viewHolder, final int i) { viewHolder.textView.setText(\"Hello\"); viewHolder.textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mListener.onClick(i); } }); } @Override public int getItemCount() { return 80; } class LinearViewHolder extends RecyclerView.ViewHolder { private TextView textView; public LinearViewHolder (View itemView) { super(itemView); textView = itemView.findViewById(R.id.tv_title); } } public interface OnItemClickListener { void onClick(int pos); } } 然后看下水平滚动的布局效果： 水平滚动布局效果mark \" 水平滚动布局效果 接着说下网格布局 只需要变更一下这里，其他都按水平滚动布局来写就行，注意文件截图位置，下面截图有 变更文","date":"2019-05-23","objectID":"/android-learning-recycleview-second/:0:1","tags":["Android"],"title":"Android学习RecyclerView笔记二","uri":"/android-learning-recycleview-second/"},{"categories":["Android"],"content":"记载RecyclerView的列表布局","date":"2019-05-22","objectID":"/android-learning-recycleview-first/","tags":["Android"],"title":"Android学习RecyclerView笔记一","uri":"/android-learning-recycleview-first/"},{"categories":["Android"],"content":" Android学习RecyclerView笔记二 ： https://yqqy.top/android-learning-recycleview-second Android学习RecyclerView笔记三 ： https://yqqy.top/android-learning-recycleview-third 记录一下RecyclerView的一些写法和特点，毕竟是用了adapter，赶紧来梳理一下。RecyclerView是Android 5.0推出的，是support-v7包中的新组件。 ","date":"2019-05-22","objectID":"/android-learning-recycleview-first/:0:0","tags":["Android"],"title":"Android学习RecyclerView笔记一","uri":"/android-learning-recycleview-first/"},{"categories":["Android"],"content":"STEP 记录的是RecyclerView的列表布局 整体写法如下 LinearAdapter-\u003eLinearRecyclerViewAvtivity-\u003eRecyclerActivity 整体思路如下 LinearAdapter\u003c-LinearRecyclerViewAvtivity\u003c-RecyclerActivity 首先我们先引入V7包，在build.gradle中写这么一行代码 implementation 'com.android.support:design:28.0.0' 然后我们重新创建一个空的 activity 并将其命名为 RecyclerViewActivity.java 然后我们给其布局一个xml 命名为 activity_recycler_view.xml 画一个按钮用来点击跳转到演示页面，界面如下： activity_recycler_view.xmlmark \" activity_recycler_view.xml 代码如下： package com.helloworld.recyclerview; import android.content.Intent; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import com.helloworld.R; public class RecyclerViewActivity extends AppCompatActivity { private Button mBtnLinear; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycler_view); mBtnLinear = findViewById(R.id.btn_linear); mBtnLinear.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(RecyclerViewActivity.this,LinearRecyclerViewActivity.class); startActivity(intent); } }); } } 然后我们在LinearRecyclerViewAvtivity对应的创建其布局文件，命名为 activity_linear_recycler_view.xml 布局RecyclerView activity_linear_recycler_view.xmlmark \" activity_linear_recycler_view.xml 回到LinearRecyclerViewAvtivity – 这里介绍一下RecyclerView的两个属性属性 –RecyclerView.setLayoutManager(LinearLayoutManger()) // 线性布局管理 –RecyclerView.addItemDecoration() //添加分割线 然后我们去设置adapter 先贴代码： package com.helloworld.recyclerview; import android.graphics.Rect; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; import android.widget.Toast; import com.helloworld.R; public class LinearRecyclerViewActivity extends AppCompatActivity { private RecyclerView mRvMain; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_linear_recycler_view); mRvMain = findViewById(R.id.rv_main); mRvMain.setLayoutManager(new LinearLayoutManager(LinearRecyclerViewActivity.this)); // 设置线性布局管理 mRvMain.addItemDecoration(new MyDecoration()); // 设置分割线，调用MyDecoration这个类 mRvMain.setAdapter(new LinearAdapter(LinearRecyclerViewActivity.this, new LinearAdapter.OnItemClickListener() { @Override // 从LinearAdapter中传入索引pos public void onClick(int pos) { Toast.makeText(LinearRecyclerViewActivity.this,\"click...\" + pos,Toast.LENGTH_SHORT).show(); } })); } /** * 自定义MyDecoration类，继承RecyclerView.ItemDecoration */ class MyDecoration extends RecyclerView.ItemDecoration { @Override public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.set(0,0,0,getResources().getDimensionPixelOffset(R.dimen.dividerHeight)); // 设置分割线在下面，线宽为1dp } } } 接着就是 LinearAdapter ，这里注意创建class时，要让其继承在 RecyclerView.Adapter 下 点开继承的类查看方法，发现是一个泛型 继承于 ViewHolder ViewHoldermark \" ViewHolder 我们自己写一个类继承 RecyclerView.ViewHolder 自定义mark \" 自定义 然后将泛型传进来 泛型mark \" 泛型 这里再记录一下 LayoutInflater 的使用 –LayoutInflater这个类的作用类似于findViewById()。不同点是LayoutInflater是用来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件(如Button、TextView等)。 onCreateViewHolder（）方法，负责承载每个子项的布局。它有两个参数，第一个按照我的理解来说是视图组件，第二个是索引; onBindViewHolder()方法，负责将每个子项holder绑定数据。俩参数分别是绑定的视图组件，索引； 为什么是按照我的理解呢，因为现在这俩参数全部更新了，也就是百度到的都不一样，之前的第二个参数是type，组件类型，现在是i,so,是按照我的理解 在LinearAdapter中返回点击的组件的索引，LinearRecyclerViewActivity接口，并用Toast返回提示信息 写一个接口实现回调方法，目的是为了传入我们点击的索引 1mark \" 1 2mark \" 2 3mark \" 3 在 getItemCount 方法中先写死，创建30个 代码如下： package com.helloworld.recyclerview; import android.content.Context; import android.support.annotation.NonNull; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.vie","date":"2019-05-22","objectID":"/android-learning-recycleview-first/:0:1","tags":["Android"],"title":"Android学习RecyclerView笔记一","uri":"/android-learning-recycleview-first/"},{"categories":["MySQL"],"content":"这是我的第一篇MySQL复习笔记","date":"2019-05-20","objectID":"/mysql-note-first/","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"MySQL复习笔记二： http://www.yqqy.top/notes/426 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:0","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"创建数据库（此处按照课本创建学生管理系统） create database student ","date":"2019-05-20","objectID":"/mysql-note-first/:0:1","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"显示创建的数据库 show databases ","date":"2019-05-20","objectID":"/mysql-note-first/:0:2","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"使用 use 数据库 来选择数据库进行操作 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:3","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"给数据库添加 表，并为其添加数据 create table xs(sno char(14) primary key, sname char(20)) 上面这行sql语句意思是创建 xs 这个表，并添加两个数据，sno(学生学号) sname(学生姓名) 并将sno 设置为主键 同理我们创建课程表，选课表 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:4","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"展示创建的表 show tables 我们就看到了刚创建好的三个表 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:5","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"现在我们为此插入数据 我们给kc（课程）这个表插入了三个数据 我们给xk（选课）这个表插入三条数据 最后一个数据插入sno主键冲突，后面已改 20170201 改为 20170202 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:6","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"我们来看下刚刚插入的数据 select * from 表名 * 代表所有 先看kc（课程）这个表 然后是xk（选课）这个表 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:7","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"我们删除一条数据 delete from 表名 where 条件 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:8","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"带入条件查询 查询学生成绩为90的信息 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:9","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"增加数据库字段 alter table 表名 add 字段名 用 desc 表名 查到字段已经加入进来了 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:10","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"修改数据 update 表名 set key = value where 条件 key 此处代表是字段名，value此处代表是值 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:11","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"判断是否查询值为空 在上面查询 xk(选课) 这个表发现前面两个的dept这个字段值是 null 那么我们先看 select * from xk where dept = null 是否可以 我们来写正确的sql语句 is null ","date":"2019-05-20","objectID":"/mysql-note-first/:0:12","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"连表查询 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:13","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"带查询条件的连表查询 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:14","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"as 修改连表查询的名称 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:15","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"多表之间的join连接 ansi方式 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:16","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"多表之间的连接方式 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:17","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"三表联合查询的方法 最笨的办法 依次查询 外连接方法 （左连接方法） 我们发现这个地方比普通方法多了一条数据，原因是普通方法如果出现null就查不到 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:18","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"创建视图 view create or replace view 视图名 AS select语句 后面的select是一般的查询语句就行，此处是三个表联合查询 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:19","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"查询视图 show tables ","date":"2019-05-20","objectID":"/mysql-note-first/:0:20","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"导出数据库 （在cmd窗口） mysqldump -u 账号 -p 数据库名字 \u003e 路径 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:21","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["MySQL"],"content":"导入数据库 (在cmd窗口) mysql -u 账号 -p 数据库名字 \u003c 路径 ","date":"2019-05-20","objectID":"/mysql-note-first/:0:22","tags":["MySQL"],"title":"MySQL复习笔记一","uri":"/mysql-note-first/"},{"categories":["Tips"],"content":"虽说用了好久的IDM,但是还是遇到了不会的问题，IDM怎么设置代理配合Shadowsocks下载国外文件？","date":"2019-05-12","objectID":"/idm-shadowsocks-download/","tags":["Soft"],"title":"IDM怎么设置代理配合Shadowsocks下载国外文件","uri":"/idm-shadowsocks-download/"},{"categories":["Tips"],"content":"起因 虽说用了好久的IDM,但是还是遇到了不会的问题，IDM怎么设置代理配合Shadowsocks下载国外文件？今天老师让我帮他下载国外的文档，原因是他自己用浏览器下载总是断，又不能断线续传，那我就想到了IDM。然鹅IDM下载国内的资源都是很给力的，下载国外的资源一直是连接不成功。就是这个逼样。 ","date":"2019-05-12","objectID":"/idm-shadowsocks-download/:0:1","tags":["Soft"],"title":"IDM怎么设置代理配合Shadowsocks下载国外文件","uri":"/idm-shadowsocks-download/"},{"categories":["Tips"],"content":"介绍 Shadowsocks是属于SOCKS5代理 ，除非其他软件支持 设置SOCKS5代理 ，比如：IDM你设置SOCKS5代理 127.0.0.1 1080 ，IDM就会走Shadowsocks了，还有浏览器也是默认读取系统代理设置的。不过首先我们设置连接方式为PAC，全局也是可以，不过此方法不合适，PAC也有好处，就是在国内下载资源，会自动切换下载源。 注意： 1080不是固定，只是你所代理的IP，所以记得灵活改变 ","date":"2019-05-12","objectID":"/idm-shadowsocks-download/:0:2","tags":["Soft"],"title":"IDM怎么设置代理配合Shadowsocks下载国外文件","uri":"/idm-shadowsocks-download/"},{"categories":["Tips"],"content":"具体设置方法如下 ","date":"2019-05-12","objectID":"/idm-shadowsocks-download/:0:3","tags":["Soft"],"title":"IDM怎么设置代理配合Shadowsocks下载国外文件","uri":"/idm-shadowsocks-download/"},{"categories":["PHP"],"content":"记载PHP三种内置函数生成随机数的方法","date":"2019-05-06","objectID":"/php-three-generate-random/","tags":["PHP"],"title":"PHP的三种内置函数生成随机数的方法","uri":"/php-three-generate-random/"},{"categories":["PHP"],"content":"1.rand函数 rand() 函数可以不加任何参数，就可以生成随机整数。如果要设置随机数范围，可以在函数中设置 min 和 max 的值。 echo rand() / echo rand(1, 10) ","date":"2019-05-06","objectID":"/php-three-generate-random/:1:0","tags":["PHP"],"title":"PHP的三种内置函数生成随机数的方法","uri":"/php-three-generate-random/"},{"categories":["PHP"],"content":"2.mt_rand函数 mt_rand() 函数是使用 Mersenne Twister算法（我也不知道是啥）返回随机整数，与rand() 函数的主要区别是： mt_rand() 产生随机数值的平均速度比rand() 快4倍。（就是快了） echo mt_rand() / echo mt_rand(1, 10) ","date":"2019-05-06","objectID":"/php-three-generate-random/:2:0","tags":["PHP"],"title":"PHP的三种内置函数生成随机数的方法","uri":"/php-three-generate-random/"},{"categories":["PHP"],"content":"3.uniqid函数 uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。默认生成ID的长度为13位或者23位，由英文字母和数字组成。uniqid() 函数有两个参数，格式如下： uniqid(prefix,more_entropy) 参数一： prefix: 生成ID的前缀 参数二： more_entropy: 是否添加额外的熵 echo uniqid(); // 生成13位字符串，如：55f540e273e93 echo uniqid('one.'); // 生成前缀为one.加13位随机字符的字符串，如：one.55f540e273e93 echo uniqid('two.', true); // 生成前缀为two.加23位随机字符的字符串（加了熵），如：two.55f540e273e932.77804707，比上面的多了 10 位，即多了：2.77804707 ","date":"2019-05-06","objectID":"/php-three-generate-random/:3:0","tags":["PHP"],"title":"PHP的三种内置函数生成随机数的方法","uri":"/php-three-generate-random/"},{"categories":["MySQL"],"content":"在表a的 第b 条数据要 update 数据的时候，检查这个表中的所有数据中有没有与要更新的数据重复，如果有即不更新，没有即更新，起初是理解错了目的，以为是单一数据不能重复，设置了唯一索引 unique 后来和我说不是那样的效果，故改之~~~","date":"2019-05-05","objectID":"/the-same-table-check-repeat/","tags":["MySQL"],"title":"同一个表下update数据并检测是否重复","uri":"/the-same-table-check-repeat/"},{"categories":["MySQL"],"content":"要实现的效果 在表 a 的 第 b 条数据要 update 数据的时候，检查这个表中的所有数据中有没有与要更新的数据重复，如果有即不更新，没有即更新，起初是理解错了目的，以为是单一数据不能重复，设置了唯一索引 unique 后来和我说不是那样的效果，故改之~~~ 比如直接写表名，就是这样的错误 ","date":"2019-05-05","objectID":"/the-same-table-check-repeat/:0:1","tags":["MySQL"],"title":"同一个表下update数据并检测是否重复","uri":"/the-same-table-check-repeat/"},{"categories":["MySQL"],"content":"代码如下 UPDATE 表名 SET 字段名1 = '字段value1', 字段名2 = '字段value2', WHERE id = '索引' # 这里是为了设置索引 AND ( SELECT COUNT(*) FROM 表名 WHERE 条件 ) = 0 # 等于0 是为了反条件 ","date":"2019-05-05","objectID":"/the-same-table-check-repeat/:0:2","tags":["MySQL"],"title":"同一个表下update数据并检测是否重复","uri":"/the-same-table-check-repeat/"},{"categories":["PHP"],"content":"在开发过程中，经常会出现表单出错而返回页面的时候填写的信息全部丢失的情况。正好碰到帮别人写表单多次提交之后，返回时候提示确认重新提交表单，一句代码解决","date":"2019-05-04","objectID":"/php-form-repeat-submit/","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"描述 在开发过程中，经常会出现表单出错而返回页面的时候填写的信息全部丢失的情况。正好碰到帮别人写表单多次提交之后，返回时候提示确认重新提交表单，如图 问题mark \" 问题 ","date":"2019-05-04","objectID":"/php-form-repeat-submit/:1:0","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"方案 解决办法一句代码，为了支持页面回跳。 header('Cache-control: private, must-revalidate'); ","date":"2019-05-04","objectID":"/php-form-repeat-submit/:2:0","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"原理 提交之后立马清除缓存控制 ","date":"2019-05-04","objectID":"/php-form-repeat-submit/:3:0","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"相关缓存指令 指令mark \" 指令 ","date":"2019-05-04","objectID":"/php-form-repeat-submit/:4:0","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"搬砖地址 原文有8种防止重复提交表单机制，我遇到一种，故介绍一种，了解其他请查看原文 https://www.cnblogs.com/myon/p/6636934.html ","date":"2019-05-04","objectID":"/php-form-repeat-submit/:5:0","tags":["PHP"],"title":"PHP防止表单重复提交策略","uri":"/php-form-repeat-submit/"},{"categories":["PHP"],"content":"使用TP框架做项目时，在启用REWRITE的伪静态功能的时候，首页可以访问，但是访问其它页面的时候，就提示：“No input file specified.”","date":"2019-04-23","objectID":"/php-no-input-file-specified/","tags":["PHP","ThinkPHP"],"title":"解决PHP5.6版本“No input file specified”","uri":"/php-no-input-file-specified/"},{"categories":["PHP"],"content":"搬砖 使用TP框架做项目时，在启用REWRITE的伪静态功能的时候，首页可以访问，但是访问其它页面的时候，就提示：“No input file specified.” ","date":"2019-04-23","objectID":"/php-no-input-file-specified/:0:1","tags":["PHP","ThinkPHP"],"title":"解决PHP5.6版本“No input file specified”","uri":"/php-no-input-file-specified/"},{"categories":["PHP"],"content":"原因 原因在于使用的PHP5.6是fast_cgi模式，而在某些情况下，不能正确识别path_info所造成的错误，“No input file specified.”，是没有得到有效的文件路径造成的。 ","date":"2019-04-23","objectID":"/php-no-input-file-specified/:0:2","tags":["PHP","ThinkPHP"],"title":"解决PHP5.6版本“No input file specified”","uri":"/php-no-input-file-specified/"},{"categories":["PHP"],"content":"解决办法如下 在 public/.htaccess中修改加一个 “？”号 ","date":"2019-04-23","objectID":"/php-no-input-file-specified/:0:3","tags":["PHP","ThinkPHP"],"title":"解决PHP5.6版本“No input file specified”","uri":"/php-no-input-file-specified/"},{"categories":["PHP"],"content":"学习之余做的简单知识管理系统，使用MVC架构编写，写法较为简单，适合小白阅读，前后端采用引导布局，前台是使用jQuery的进行前台验证，操作表单等操作，使用Ajax的验证后台数据，适合学习。","date":"2019-04-05","objectID":"/my-php-first-project/","tags":["PHP"],"title":"小作品-知识管理系统","uri":"/my-php-first-project/"},{"categories":["PHP"],"content":" 学习之余做的简单知识管理系统，使用MVC架构编写，写法较为简单，适合小白阅读，前后端采用引导布局，前台是使用jQuery的进行前台验证，操作表单等操作，使用Ajax的验证后台数据，适合学习。 ","date":"2019-04-05","objectID":"/my-php-first-project/:0:0","tags":["PHP"],"title":"小作品-知识管理系统","uri":"/my-php-first-project/"},{"categories":["PHP"],"content":"图片展示 1mark \" 1 2mark \" 2 3mark \" 3 4mark \" 4 5mark \" 5 ","date":"2019-04-05","objectID":"/my-php-first-project/:1:0","tags":["PHP"],"title":"小作品-知识管理系统","uri":"/my-php-first-project/"},{"categories":["PHP"],"content":"下载地址 https://github.com/yqchilde/kms ","date":"2019-04-05","objectID":"/my-php-first-project/:2:0","tags":["PHP"],"title":"小作品-知识管理系统","uri":"/my-php-first-project/"},{"categories":["Tips"],"content":"Sublime常用快捷键整理","date":"2019-03-28","objectID":"/sublime-common-shortcuts/","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"Sublime常用快捷键 整理人：yqchilde ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:0","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:1","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:2","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:3","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 Emmet插件快捷键 缩写:! 缩写:html:5 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:4","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"#(id) .(class) [href=#] 缩写：p#info 缩写：p.info 缩写：a[href=’#’] \u003cp id=\"info\"\u003e\u003c/p\u003e \u003cp class=\"info\"\u003e\u003c/p\u003e \u003ca href=\"#\"\u003e\u003c/a\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:5","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"后代 \u003e 缩写：div#warp\u003eul\u003eli*5 \u003cdiv id=\"warp\"\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:6","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"兄弟：+ 缩写：div#warp\u003ep.one+span.two \u003cdiv id=\"warp\"\u003e \u003cp class=\"one\"\u003e\u003c/p\u003e \u003cspan class=\"two\"\u003e\u003c/span\u003e \u003c/div\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:7","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"^ 可以使该符号前的标签提升一行（换行符） 缩写 p.class\u003espan^div.info 缩写 ul\u003eli*5^ol\u003eli*6 \u003cp class=\"class\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/p\u003e \u003cdiv class=\"info\"\u003e\u003c/div\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:8","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"分组 通过嵌套和括号快速生成一些代码块 缩写：(div.foo\u003eh1\u003ep)+(div.bar\u003e[h3]\u003ep) \u003cdiv class=\"foo\"\u003e \u003ch1\u003e \u003cp\u003e\u003c/p\u003e \u003c/h1\u003e \u003c/div\u003e \u003cdiv class=\"bar\"\u003e \u003ch3\u003e \u003cp\u003e\u003c/p\u003e \u003c/h3\u003e \u003c/div\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:9","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"隐藏标签的快捷键 .itrm 表示 div.item 但是在不同的标签下面代表的情况不一样 li : 在ul或者ol中 tr : table td : 用于tr中 option : 用于select ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:10","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"定义多个元素 缩写：ul\u003eli*3 \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e 缩写：ul\u003eli.item$*3 \u003cul\u003e \u003cli class=\"item1\"\u003e\u003c/li\u003e \u003cli class=\"item2\"\u003e\u003c/li\u003e \u003cli class=\"item3\"\u003e\u003c/li\u003e \u003c/ul\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:11","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"css 缩写 w100 =\u003e width:100px; m100 =\u003emargin: 100px; h100 =\u003e height :100px; 默认是 px 其他的单位需要表示 p 表示% e 表示 em x 表示 ex 缩写： @f 缩写： @f @font-face { font-family:; src:url(); } @font-face { font-family: 'FontName'; src: url('FileName.eot'); src: url('FileName.eot?#iefix') format('embedded-opentype'), url('FileName.woff') format('woff'), url('FileName.ttf') format('truetype'), url('FileName.svg#FontName') format('svg'); font-style: normal; font-weight: normal; } ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:12","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"模糊匹配 缩写： fz =\u003e font-size:;  缩写： fs =\u003e font-style: italic; ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:13","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"供应商模式 w 表示 -webkit- m 表示 -moz- s 表示 -ms- o 表示 -o- ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:14","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"渐变 缩写：[lg](left,#fff 50%, #000) background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000)); background-image: -webkit-linear-gradient(left, #fff 50%, #000); background-image: -moz-linear-gradient(left, #fff 50%, #000); background-image: -o-linear-gradient(left, #fff 50%, #000); background-image: linear-gradient(left, #fff 50%, #000); ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:15","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"},{"categories":["Tips"],"content":"填充内容 //缩写：h$[title=item$]{Header $}*3 \u003ch1 title=\"item1\"\u003eHeader 1\u003c/h1\u003e \u003ch2 title=\"item2\"\u003eHeader 2\u003c/h2\u003e \u003ch3 title=\"item3\"\u003eHeader 3\u003c/h3\u003e //缩写：ul\u003eli.item$$${item $}*5 \u003cul\u003e \u003cli class=\"item001\"\u003eitem 1\u003c/li\u003e \u003cli class=\"item002\"\u003eitem 2\u003c/li\u003e \u003cli class=\"item003\"\u003eitem 3\u003c/li\u003e \u003cli class=\"item004\"\u003eitem 4\u003c/li\u003e \u003cli class=\"item005\"\u003eitem 5\u003c/li\u003e \u003c/ul\u003e 缩写：ul\u003eli.item$@-*5 //$@- 倒数 \u003cul\u003e \u003cli class=\"item5\"\u003e\u003c/li\u003e \u003cli class=\"item4\"\u003e\u003c/li\u003e \u003cli class=\"item3\"\u003e\u003c/li\u003e \u003cli class=\"item2\"\u003e\u003c/li\u003e \u003cli class=\"item1\"\u003e\u003c/li\u003e \u003c/ul\u003e 缩写：ul\u003eli.item$@3*5 //$@3 从三开始 \u003cul\u003e \u003cli class=\"item3\"\u003e\u003c/li\u003e \u003cli class=\"item4\"\u003e\u003c/li\u003e \u003cli class=\"item5\"\u003e\u003c/li\u003e \u003cli class=\"item6\"\u003e\u003c/li\u003e \u003cli class=\"item7\"\u003e\u003c/li\u003e \u003c/ul\u003e 缩写：ul\u003eli.item$@-3*5 //$@-3 倒数到三 \u003cul\u003e \u003cli class=\"item7\"\u003e\u003c/li\u003e \u003cli class=\"item6\"\u003e\u003c/li\u003e \u003cli class=\"item5\"\u003e\u003c/li\u003e \u003cli class=\"item4\"\u003e\u003c/li\u003e \u003cli class=\"item3\"\u003e\u003c/li\u003e \u003c/ul\u003e ","date":"2019-03-28","objectID":"/sublime-common-shortcuts/:0:16","tags":["Soft"],"title":"Sublime及Emmet插件快捷键","uri":"/sublime-common-shortcuts/"}]